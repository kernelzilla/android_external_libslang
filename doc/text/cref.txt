  The SS--LLaanngg C Library Reference
  John E. Davis, jed@jedsoft.org
  May 28, 2009
  ____________________________________________________________


  11..  FFuunnccttiioonnss ddeeaalliinngg wwiitthh UUTTFF--88 eennccooddeedd ssttrriinnggss

  11..11..  SSLLuuttff88__sskkiipp__cchhaarr

      SSyynnooppssiiss
        Skip past a UTF-8 encoded character

      UUssaaggee
        SLuchar_Type *SLutf8_skip_char (SLuchar_Type *u, SLuchar_Type
        *umax)

      DDeessccrriippttiioonn
        The SLutf8_skip_char function returns a pointer to the character
        immediately following the UTF-8 encoded character at u. It will
        make no attempt to examine the bytes at the position umax and
        beyond. If the bytes at u do not represent a valid or legal
        UTF-8 encoded sequence, a pointer to the byte following u will
        be returned.

      NNootteess
        Unicode combining characters are treated as distinct characters
        by this function.

      SSeeee AAllssoo
        SLutf8_skip_chars, SLutf8_bskip_char, SLutf8_strlen

  11..22..  SSLLuuttff88__sskkiipp__cchhaarrss

      SSyynnooppssiiss
        Skip past a specified number of characters in a UTF-8 encoded
        string

      UUssaaggee
        SLuchar_Type *SLutf8_skip_chars (u, umax, num, dnum,
        ignore_combining)

              SLuchar_Type *u, *umax;
              unsigned int num;
              unsigned int *dnum;
              int ignore_combining;

      DDeessccrriippttiioonn
        This functions attempts to skip forward past num UTF-8 encoded
        characters at u returning the actual number skipped via the
        parameter dnum. It will make no attempt to examine bytes at umax
        and beyond. Unicode combining characters will not be counted if
        ignore_combining is non-zero, otherwise they will be treated as
        distinct characters. If the input contains an invalid or illegal
        UTF-8 sequence, then each byte in the sequence will be treated
        as a single character.

      SSeeee AAllssoo
        SLutf8_skip_char, SLutf8_bskip_chars

  11..33..  SSLLuuttff88__bbsskkiipp__cchhaarr

      SSyynnooppssiiss
        Skip backward past a UTF-8 encoded character

      UUssaaggee
        SLuchar_Type *SLutf8_bskip_char (SLuchar_Type *umin,
        SLuchar_Type *u)

      DDeessccrriippttiioonn
        The SLutf8_bskip_char skips backward to the start of the UTF-8
        encoded character immediately before the position u.  The
        function will make no attempt to examine characters before the
        position umin. UTF-8 combining characters are treated as
        distinct characters.

      SSeeee AAllssoo
        SLutf8_bskip_chars, SLutf8_skip_char

  11..44..  SSLLuuttff88__bbsskkiipp__cchhaarrss

      SSyynnooppssiiss
        Skip backward past a specified number of UTF-8 encoded
        characters

      UUssaaggee
        SLuchar_Type *SLutf8_bskip_chars (umin, u, num, dnum,
        ignore_combining)

             SLuchar_Type *umin, *u;
             unsigned int num;
             unsigned int *dnum;
             int ignore_combining;

      DDeessccrriippttiioonn
        This functions attempts to skip backward past num UTF-8 encoded
        characters occuring immediately before u. It returns the the
        actual number skipped via the parameter dnum. No attempt will be
        made to examine the bytes occuring before umin.  Unicode
        combining characters will not be counted if ignore_combining is
        non-zero, otherwise they will be treated as distinct characters.
        If the input contains an invalid or illegal UTF-8 sequence, then
        each byte in the sequence will be treated as a single character.

      SSeeee AAllssoo
        SLutf8_skip_char, SLutf8_bskip_chars

  11..55..  SSLLuuttff88__ddeeccooddee

      SSyynnooppssiiss
        Decode a UTF-8 encoded character sequence

      UUssaaggee
        SLuchar_Type *SLutf8_decode (u, umax, w, nconsumedp

             SLuchar_Type *u, *umax;
             SLwchar_Type *w;
             unsigned int *nconsumedp;

      DDeessccrriippttiioonn
        The SLutf8_decode function decodes the UTF-8 encoded character
        occuring at u and returns the decoded character via the
        parameter w. No attempt will be made to examine the bytes at
        umax and beyond. If the parameter nconsumedp is non-NULL, then
        the number of bytes consumed by the function will be returned to
        it. If the sequence at u is invalid or illegal, the function
        will return NULL and with the number of bytes consumed by the
        function equal to the size of the invalid sequence. Otherwise
        the function will return a pointer to byte following encoded
        sequence.

      SSeeee AAllssoo
        SLutf8_decode, SLutf8_strlen, SLutf8_skip_char

  11..66..  SSLLuuttff88__eennccooddee

      SSyynnooppssiiss
        UTF-8 encode a character

      UUssaaggee
        SLuchar_Type *SLutf8_encode (w, u, ulen)

             SLwchar_Type w;
             SLuchar_Type *u;
             unsigned int ulen;

      DDeessccrriippttiioonn
        This function UTF-8 encodes the Unicode character represented by
        w and stored the encoded representation in the buffer of size
        ulen bytes at u. The function will return NULL if the size of
        the buffer is too small to represent the UTF-8 encoded
        character, otherwise it will return a pointer to the byte
        following encoded representation.

      NNootteess
        This function does not null terminate the resulting byte
        sequence.  The function SLutf8_encode_null_terminate may be used
        for that purpose.

        To guarantee that the buffer is large enough to hold the encoded
        bytes, its size should be at least SLUTF8_MAX_BLEN bytes.

        The function will encode illegal Unicode characters, i.e.,
        characters in the range 0xD800-0xFFFF (the UTF-16 surrogates)
        and 0xFFFE-0xFFFF.

      SSeeee AAllssoo
        SLutf8_decode, SLutf8_encode_bytes, SLutf8_encode_null_terminate

  11..77..  SSLLuuttff88__ssttrrlleenn

      SSyynnooppssiiss
        Determine the number of characters in a UTF-8 sequence

      UUssaaggee
        unsigned int SLutf8_strlen (SLuchar_Type *s, int
        ignore_combining)

      DDeessccrriippttiioonn
        This function may be used to determine the number of characters
        represented by the null-terminated UTF-8 byte sequence. If the
        ignore_combining parameter is non-zero, then Unicode combining
        characters will not be counted.

      SSeeee AAllssoo
        SLutf8_skip_chars, SLutf8_decode

  11..88..  SSLLuuttff88__eexxttrraacctt__uuttff88__cchhaarr

      SSyynnooppssiiss
        Extract a UTF-8 encoded character

      UUssaaggee
        SLuchar_Type *SLutf8_extract_utf8_char (u, umax, buf)

             SLuchar_Type *u, *umax, *buf;

      DDeessccrriippttiioonn
        This function extracts the bytes representing UTF-8 encoded
        character at u and places them in the buffer buf, and then null
        terminates the result. The buffer is assumed to consist of at
        least SLUTF8_MAX_BLEN+1 bytes, where the extra byte may be
        necessary for null termination. No attempt will be made to
        examine the characters at umax and beyond. If the byte-sequence
        at u is an illegal or invalid UTF-8 sequence, then the byte at u
        will be copied to the buffer. The function returns a pointer to
        the byte following copied bytes.

      NNootteess
        One may think of this function as the single byte analogue of

               if (u < umax)
                 {
                    buf[0] = *u++;
                    buf[1] = 0;
                 }

      SSeeee AAllssoo
        SLutf8_decode, SLutf8_skip_char

  11..99..  SSLLuuttff88__eennccooddee__nnuullll__tteerrmmiinnaattee

      SSyynnooppssiiss
        UTF-8 encode a character and null terminate the result

      UUssaaggee
        SLuchar_Type *SLutf8_encode_null_terminate (w, buf)

             SLwchar_Type w;
             SLuchar_Type *buf;

      DDeessccrriippttiioonn
        This function has the same functionality as SLutf8_encode,
        except that it also null terminates the encoded sequences. The
        buffer buf, where the encoded sequence is placed, is assumed to
        consist of at least SLUTF8_MAX_BLEN+1 bytes.

      SSeeee AAllssoo
        SLutf8_encode

  11..1100..  SSLLuuttff88__ssttrruupp

      SSyynnooppssiiss
        Uppercase a UTF-8 encoded string

      UUssaaggee
        SLuchar_Type *SLutf8_strup (SLuchar_Type *u, SLuchar_Type *umax)

      DDeessccrriippttiioonn
        The SLutf8_strup function returns the uppercase equivalent of
        UTF-8 encoded sequence of umax-u bytes at u. The result will be
        returned as a null-terminated SLstring and should be freed with
        SLang_free_slstring when it is nolonger needed. If the function
        encounters an invalid of illegal byte sequence, then the byte-
        sequence will be copied as as-is.

      SSeeee AAllssoo
        SLutf8_strlow, SLwchar_toupper

  11..1111..  SSLLuuttff88__ssttrrlloo

      SSyynnooppssiiss
        Lowercase a UTF-8 encoded string

      UUssaaggee
        SLuchar_Type *SLutf8_strlo (SLuchar_Type *u, SLuchar_Type *umax)

      DDeessccrriippttiioonn
        The SLutf8_strlo function returns the lowercase equivalent of
        UTF-8 encoded sequence of umax-u bytes at u. The result will be
        returned as a null-terminated SLstring and should be freed with
        SLang_free_slstring when it is nolonger needed. If the function
        encounters an invalid of illegal byte sequence, then the byte-
        sequence will be copied as as-is.

      SSeeee AAllssoo
        SLutf8_strlow, SLwchar_toupper

  11..1122..  SSLLuuttff88__ssuubbsstt__wwcchhaarr

      SSyynnooppssiiss
        Replace a character in a UTF-8 encoded string

      UUssaaggee
        SLstr_Type *SLutf8_subst_wchar (u, umax, wch,
        nth,ignore_combining)

             SLuchar_Type *u, *umax;
             SLwchar_Type wch;
             unsigned int nth;
             int ignore_combining;

      DDeessccrriippttiioonn
        The SLutf8_subst_wchar function replaces the UTF-8 sequence
        representing the nth character of u by the UTF-8 representation
        of the character wch. If the value of the ignore_combining
        parameter is non-zero, then combining characters will not be
        counted when computing the position of the nth character. In
        addition, if the nth character contains any combining
        characters, then the byte-sequence associated with those
        characters will also be replaced.

        Since the byte sequence representing wch could be longer than
        the sequence of the nth character, the function returns a new
        copy of the resulting string as an SLSTRING. Hence, the calling
        function should call SLang_free_slstring when the result is
        nolonger needed.

      SSeeee AAllssoo
        SLutf8_strup, SLutf8_strlow, SLutf8_skip_chars, SLutf8_strlen

  11..1133..  SSLLuuttff88__ccoommppaarree

      SSyynnooppssiiss
        Compare two UTF-8 encoded sequences

      UUssaaggee
        int SLutf8_compare (a, amax, b, bmax, nchars, case_sensitive)

             SLuchar_Type *a, *amax;
             SLuchar_Type *b, *bmax;
             unsigned int nchars;
             int case_sensitive;

      DDeessccrriippttiioonn
        This function compares nchars of one UTF-8 encoded character
        sequence to another by performing a character by character
        comparison.  The function returns 0, +1, or -1 according to
        whether the string a is is equal to, greater than, or less than
        the string at b. At most nchars characters will be tested. The
        parameters amax and bmax serve as upper boundaries of the
        strings a and b, resp.

        If the value of the case_sensitive parameter is non-zero, then a
        case-sensitive comparison will be performed, otherwise
        characters will be compared in a case-insensitive manner.

      NNootteess
        For case-sensitive comparisons, this function is analogous to
        the standard C library's strncmp function. However,
        SLutf8_compare can also cope with invalid or illegal UTF-8
        sequences.

      SSeeee AAllssoo
        SLutf8_strup, SLutf8_strlen, SLutf8_strlen

  22..  CChhaarraacctteerr ccllaassssiiffiiccaattiioonn ffuunnccttiioonnss

  22..11..  SSLLwwcchhaarr__ttoouuppppeerr

      SSyynnooppssiiss
        Uppercase a Unicode character

      UUssaaggee
        SLwchar_Type SLwchar_toupper (SLwchar_Type wc)

      DDeessccrriippttiioonn
        SLwchar_toupper returns the uppercase equivalent of the
        specified character.

      NNootteess
        If the library is not in UTF-8 mode, then the current locale
        will be used.

      SSeeee AAllssoo
        SLwchar_tolower, SLwchar_isupper, SLutf8_strup

  22..22..  SSLLwwcchhaarr__ttoolloowweerr

      SSyynnooppssiiss
        Lowercase a Unicode character

      UUssaaggee
        SLwchar_Type SLwchar_tolower (SLwchar_Type wc)

      DDeessccrriippttiioonn
        SLwchar_tolower returns the lowercase equivalent of the
        specified character.

      NNootteess
        If the library is not in UTF-8 mode, then the current locale
        will be used.

      SSeeee AAllssoo
        SLwchar_toupper, SLwchar_islower, SLutf8_strlow

  22..33..  SSLLwwcchhaarr__wwccwwiiddtthh

      SSyynnooppssiiss
        Determine the displayable width of a wide character

      UUssaaggee
        int SLwchar_wcwidth (SLwchar_Type wc)

      DDeessccrriippttiioonn
        This function returns the number of columns necessary to display
        the specified Unicode character. Combining characters are meant
        to be combined with other characters and, as such, have 0 width.

      NNootteess
        If the library is not in UTF-8 mode, then the current locale
        will be used.

      SSeeee AAllssoo
        SLwchar_isspace, SLwchar_iscntrl

  22..44..  SSLLwwcchhaarr__iissaallnnuumm

      SSyynnooppssiiss
        Determine if a Unicode character is alphanumeric

      UUssaaggee
        int SLwchar_isalnum (SLwchar_Type wc)

      DDeessccrriippttiioonn
        SLwchar_isalnum returns a non-zero value if the Unicode
        character is alphanumeric, otherwise it returns 0.

      NNootteess
        If the library is not in UTF-8 mode, then the current locale
        will be used.

      SSeeee AAllssoo
        SLwchar_isalpha, SLwchar_isdigit, SLwchar_iscntrl

  22..55..  SSLLwwcchhaarr__iissaallpphhaa

      SSyynnooppssiiss
        Determine if a Unicode character is an alphabetic character

      UUssaaggee
        int SLwchar_isalpha (SLwchar_Type wc)

      DDeessccrriippttiioonn
        SLwchar_isalpha returns a non-zero value if the Unicode
        character is alphabetic, otherwise it returns 0.

      NNootteess
        If the library is not in UTF-8 mode, then the current locale
        will be used.

      SSeeee AAllssoo
        SLwchar_isalnum, SLwchar_isalpha, SLwchar_isdigit,
        SLwchar_iscntrl

  22..66..  SSLLwwcchhaarr__iissbbllaannkk

      SSyynnooppssiiss
        Determine if a Unicode character is a blank

      UUssaaggee
        int SLwchar_isblank (SLwchar_Type wc)

      DDeessccrriippttiioonn
        SLwchar_isblank returns a non-zero value if the Unicode
        character is a blank one (space or tab), otherwise it returns 0.

      NNootteess
        If the library is not in UTF-8 mode, then the current locale
        will be used.
      SSeeee AAllssoo
        SLwchar_isspace, SLwchar_isalpha, SLwchar_isdigit,
        SLwchar_iscntrl

  22..77..  SSLLwwcchhaarr__iissccnnttrrll

      SSyynnooppssiiss
        Determine if a Unicode character is a control character

      UUssaaggee
        int SLwchar_iscntrl (SLwchar_Type wc)

      DDeessccrriippttiioonn
        SLwchar_isblank returns a non-zero value if the Unicode
        character is a control character, otherwise it returns 0.

      NNootteess
        If the library is not in UTF-8 mode, then the current locale
        will be used.

      SSeeee AAllssoo
        SLwchar_isspace, SLwchar_isalpha, SLwchar_isdigit,
        SLwchar_isprint

  22..88..  SSLLwwcchhaarr__iissddiiggiitt

      SSyynnooppssiiss
        Determine if a Unicode character is a digit

      UUssaaggee
        int SLwchar_isdigit (SLwchar_Type wc)

      DDeessccrriippttiioonn
        This function returns a non-zero value if the specified Unicode
        character is a digit, otherwise it returns 0.

      NNootteess
        If the library is not in UTF-8 mode, then the current locale
        will be used.

      SSeeee AAllssoo
        SLwchar_isspace, SLwchar_isalpha, SLwchar_isxdigit,
        SLwchar_isprint

  22..99..  SSLLwwcchhaarr__iissggrraapphh

      SSyynnooppssiiss
        Determine if a non-space Unicode character is printable

      UUssaaggee
        int SLwchar_isgraph (SLwchar_Type wc)

      DDeessccrriippttiioonn
        This function returns a non-zero value if the specified Unicode
        character is a non-space printable character, otherwise it
        returns 0.

      NNootteess
        If the library is not in UTF-8 mode, then the current locale
        will be used.

      SSeeee AAllssoo
        SLwchar_isspace, SLwchar_isalpha, SLwchar_isdigit,
        SLwchar_isprint

  22..1100..  SSLLwwcchhaarr__iisslloowweerr

      SSyynnooppssiiss
        Determine if a Unicode character is alphanumeric

      UUssaaggee
        int SLwchar_islower (SLwchar_Type wc)

      DDeessccrriippttiioonn
        This function returns a non-zero value if the specified Unicode
        character is a lowercase one, otherwise it returns 0.

      NNootteess
        If the library is not in UTF-8 mode, then the current locale
        will be used.

      SSeeee AAllssoo
        SLwchar_isupper, SLwchar_isspace, SLwchar_isalpha,
        SLwchar_isdigit, SLwchar_iscntrl

  22..1111..  SSLLwwcchhaarr__iisspprriinntt

      SSyynnooppssiiss
        Determine if a Unicode character is printable

      UUssaaggee
        int SLwchar_isprint (SLwchar_Type wc)

      DDeessccrriippttiioonn
        This function returns a non-zero value if the specified Unicode
        character is a printable one (includes space), otherwise it
        returns 0.

      NNootteess
        If the library is not in UTF-8 mode, then the current locale
        will be used.

      SSeeee AAllssoo
        SLwchar_isgraph, SLwchar_isspace, SLwchar_isalpha,
        SLwchar_isdigit

  22..1122..  SSLLwwcchhaarr__iissppuunncctt

      SSyynnooppssiiss
        Determine if a Unicode character is a punctuation character

      UUssaaggee
        int SLwchar_ispunct (SLwchar_Type wc)

      DDeessccrriippttiioonn
        This function returns a non-zero value if the specified Unicode
        character is a punctuation character, otherwise it returns 0.

      NNootteess
        If the library is not in UTF-8 mode, then the current locale
        will be used.

      SSeeee AAllssoo
        SLwchar_isspace, SLwchar_isalpha, SLwchar_isdigit,
        SLwchar_isprint

  22..1133..  SSLLwwcchhaarr__iissssppaaccee

      SSyynnooppssiiss
        Determine if a Unicode character is a whitespace character

      UUssaaggee
        int SLwchar_isspace (SLwchar_Type wc)

      DDeessccrriippttiioonn
        This function returns a non-zero value if the specified Unicode
        character is a whitespace character, otherwise it returns 0.

      NNootteess
        If the library is not in UTF-8 mode, then the current locale
        will be used.

      SSeeee AAllssoo
        SLwchar_isblank, SLwchar_isalpha, SLwchar_isdigit,
        SLwchar_ispunct

  22..1144..  SSLLwwcchhaarr__iissuuppppeerr

      SSyynnooppssiiss
        Determine if a Unicode character is uppercase

      UUssaaggee
        int SLwchar_isupper (SLwchar_Type wc)

      DDeessccrriippttiioonn
        This function returns a non-zero value if the specified Unicode
        character is an uppercase character, otherwise it returns 0.

      NNootteess
        If the library is not in UTF-8 mode, then the current locale
        will be used.

      SSeeee AAllssoo
        SLwchar_islower, SLwchar_isspace, SLwchar_isalpha,
        SLwchar_isdigit

  22..1155..  SSLLwwcchhaarr__iissxxddiiggiitt

      SSyynnooppssiiss
        Determine if a Unicode character is a hexidecimal digit

      UUssaaggee
        int SLwchar_isxdigit (SLwchar_Type wc)

      DDeessccrriippttiioonn
        This function returns a non-zero value if the specified Unicode
        character is a hexadecimal digit character, otherwise it returns
        0.

      NNootteess
        If the library is not in UTF-8 mode, then the current locale
        will be used.

      SSeeee AAllssoo
        SLwchar_isdigit, SLwchar_isspace, SLwchar_isalpha,
        SLwchar_ispunct

  33..  SSLLsseeaarrcchh iinntteerrffaaccee FFuunnccttiioonnss

  33..11..  SSLLsseeaarrcchh__nneeww

      SSyynnooppssiiss
        Create an SLsearch_Type object

      UUssaaggee
        SLsearch_Type *SLsearch_new (SLuchar_Type *key, int
        search_flags)

      DDeessccrriippttiioonn
        The SLsearch_new function instantiates an SLsearch_Type object
        for use in ordinary searches (non-regular expression) by the
        functions in the SLsearch interface. The first argument key is a
        pointer to a null terminated string that specifies the character
        string to be searched. This character string may not contain any
        embedded null characters.

        The second argument search_flags is used to specify how the
        search is to be performed. It is a bit-mapped integer whose
        value is constructed by the bitwise-or of zero or more of the
        following:

             SLSEARCH_CASELESS
               The search shall be performed in a case-insensitive manner.

             SLSEARCH_UTF8
               Both the search string and the text to be searched is UTF-8
               encoded.

     Upon sucess, the function returns the newly created object, and
     NULL otherwise. When the search object is nolonger needed, it
     should be freed via the SLsearch_delete function.

      SSeeee AAllssoo
        SLsearch_delete, SLsearch_forward, SLsearch_backward

  33..22..  SSLLsseeaarrcchh__ddeelleettee

      SSyynnooppssiiss
        Free the memory associated with a SLsearch_Type object

      UUssaaggee
        SLsearch_delete (SLsearch_Type *)

      DDeessccrriippttiioonn
        This function should be called to free the memory associated
        with a SLsearch_Type object created by the SLsearch_new
        function. Failure to do so will result in a memory leak.

      SSeeee AAllssoo
        SLsearch_new, SLsearch_forward, SLsearch_backward

  33..33..  SSLLsseeaarrcchh__ffoorrwwaarrdd

      SSyynnooppssiiss
        Search forward in a buffer

      UUssaaggee
        SLuchar_Type SLsearch_forward (st, pmin, pmax)

             SLsearch_Type *st;
             SLuchar_Type *pmin, *pmax;

      DDeessccrriippttiioonn
        The SLsearch_forward function searches forward in the buffer
        defined by the pointers pmin and pmax. The starting point for
        the search is at the beginning of the buffer at pmin. At no
        point will the bytes at pmax and beyond be examined. The first
        parameter st, obtained by a prior call to SLsearch_new,
        specifies the object to found.  be found from a previous call to
        SLsearch_new.

        If the object was found, the pointer to the beginning of it will
        be returned. Otherwise, SLsearch_forward will return NULL.  The
        length of the object may be obtained via the SLsearch_match_len
        function.

      NNootteess
        This function uses the Boyer-Moore search algorithm when
        possible.

      SSeeee AAllssoo
        SLsearch_new, SLsearch_backward, SLsearch_delete,
        SLsearch_match_len

  33..44..  SSLLsseeaarrcchh__bbaacckkwwaarrdd

      SSyynnooppssiiss
        Search backward in a buffer
      UUssaaggee
        SLuchar_Type SLsearch_forward (st, pmin, pstart, pmax)

             SLsearch_Type *st;
             SLuchar_Type *pmin, *pstart, *pmax;

      DDeessccrriippttiioonn
        The SLsearch_forward function searches backward in the buffer
        defined by the pointers pmin and pmax. The starting point for
        the search is at the position pstart. At no point will the bytes
        at pmax and beyond be examined. The first parameter st, obtained
        by a prior call to SLsearch_new, specifies the object to found.

        If the object was found, the pointer to the beginning of it will
        be returned. Otherwise, SLsearch_forward will return NULL.  The
        length of the object may be obtained via the SLsearch_match_len
        function.

      NNootteess
        This function uses the Boyer-Moore search algorithm when
        possible.

        It is possible for the end of match to appear after the point
        where the search began (pstart).

      SSeeee AAllssoo
        SLsearch_new, SLsearch_forward, SLsearch_delete,
        SLsearch_match_len

  33..55..  SSLLsseeaarrcchh__mmaattcchh__lleenn

      SSyynnooppssiiss
        Get the length of the previous match

      UUssaaggee
        unsigned int SLsearch_match_len (SLsearch_Type *st)

      DDeessccrriippttiioonn
        The SLsearch_match_len function returns the length of the match
        from the most recent search involving the specified
        SLsearch_Type object. If the most recent search was
        unsuccessful, the function will return 0.

      SSeeee AAllssoo
        SLsearch_forward, SLsearch_backward, SLsearch_new,
        SLsearch_delete

  44..  SSccrreeeenn MMaannaaggeemmeenntt ((SSLLssmmgg)) ffuunnccttiioonnss

  44..11..  SSLLssmmgg__ffiillll__rreeggiioonn

      SSyynnooppssiiss
        Fill a rectangular region with a character

      UUssaaggee
        void SLsmg_fill_region (r, c, nr, nc, ch)

              int r
              int c
              unsigned int nr
              unsigned int nc
              unsigned char ch

      DDeessccrriippttiioonn
        The SLsmg_fill_region function may be used to a rectangular
        region with the character ch in the current color.  The
        rectangle's upper left corner is at row r and column c, and
        spans nr rows and nc columns. The position of the virtual cursor
        will be left at (r, c).

      SSeeee AAllssoo
        SLsmg_write_char, SLsmg_set_color

  44..22..  SSLLssmmgg__sseett__cchhaarr__sseett

      SSyynnooppssiiss
        Turn on or off line drawing characters

      UUssaaggee
        void SLsmg_set_char_set (int a);

      DDeessccrriippttiioonn
        SLsmg_set_char_set may be used to select or deselect the line
        drawing character set as the current character set. If a is non-
        zero, the line drawing character set will be selected.
        Otherwise, the standard character set will be selected.

      NNootteess
        There is no guarantee that this function will actually enable
        the use of line drawing characters. All it does is cause
        subsequent characters to be rendered using the terminal's
        alternate character set. Such character sets usually contain
        line drawing characters.

      SSeeee AAllssoo
        SLsmg_write_char, SLtt_get_terminfo

  44..33..  iinntt SSLLssmmgg__SSccrroollll__HHaasshh__BBoorrddeerr;;

      SSyynnooppssiiss
        Set the size of the border for the scroll hash

      UUssaaggee
        int SLsmg_Scroll_Hash_Border = 0;

      DDeessccrriippttiioonn
        This variable may be used to ignore the characters that occur at
        the beginning and the end of a row when performing the hash
        calculation to determine whether or not a line has scrolled. The
        default value is zero which means that all the characters on a
        line will be used.

      SSeeee AAllssoo
        SLsmg_refresh

  44..44..  SSLLssmmgg__ssuussppeenndd__ssmmgg

      SSyynnooppssiiss
        Suspend screen management

      UUssaaggee
        int SLsmg_suspend_smg (void)

      DDeessccrriippttiioonn
        SLsmg_suspend_smg can be used to suspend the state of the screen
        management facility during suspension of the program. Use of
        this function will reset the display back to its default state.
        The funtion SLsmg_resume_smg should be called after suspension.

        It returns zero upon success, or -1 upon error.

        This function is similar to SLsmg_reset_smg except that the
        state of the display prior to calling SLsmg_suspend_smg is
        saved.

      SSeeee AAllssoo
        SLsmg_resume_smg, SLsmg_reset_smg

  44..55..  SSLLssmmgg__rreessuummee__ssmmgg

      SSyynnooppssiiss
        Resume screen management

      UUssaaggee
        int SLsmg_resume_smg (void)

      DDeessccrriippttiioonn
        SLsmg_resume_smg should be called after SLsmg_suspend_smg to
        redraw the display exactly like it was before SLsmg_suspend_smg
        was called. It returns zero upon success, or -1 upon error.

      SSeeee AAllssoo
        SLsmg_suspend_smg

  44..66..  SSLLssmmgg__eerraassee__eeooll

      SSyynnooppssiiss
        Erase to the end of the row

      UUssaaggee
        void SLsmg_erase_eol (void);
      DDeessccrriippttiioonn
        SLsmg_erase_eol erases all characters from the current position
        to the end of the line. The newly created space is given the
        color of the current color. This function has no effect on the
        position of the virtual cursor.

      SSeeee AAllssoo
        SLsmg_gotorc, SLsmg_erase_eos, SLsmg_fill_region

  44..77..  SSLLssmmgg__ggoottoorrcc

      SSyynnooppssiiss
        Move the virtual cursor

      UUssaaggee
        void SLsmg_gotorc (int r, int c)

      DDeessccrriippttiioonn
        The SLsmg_gotorc function moves the virtual cursor to the row r
        and column c. The first row and first column is specified by r =
        0 and c = 0.

      SSeeee AAllssoo
        SLsmg_refresh

  44..88..  SSLLssmmgg__eerraassee__eeooss

      SSyynnooppssiiss
        Erase to the end of the screen

      UUssaaggee
        void SLsmg_erase_eos (void);

      DDeessccrriippttiioonn
        The SLsmg_erase_eos is like SLsmg_erase_eol except that it
        erases all text from the current position to the end of the
        display. The current color will be used to set the background of
        the erased area.

      SSeeee AAllssoo
        SLsmg_erase_eol

  44..99..  SSLLssmmgg__rreevveerrssee__vviiddeeoo

      SSyynnooppssiiss
        Set the current color to 1

      UUssaaggee
        void SLsmg_reverse_video (void);

      DDeessccrriippttiioonn
        This function is nothing more than SLsmg_set_color(1).

      SSeeee AAllssoo
        SLsmg_set_color

  44..1100..  SSLLssmmgg__sseett__ccoolloorr ((iinntt))

      SSyynnooppssiiss
        Set the current color

      UUssaaggee
        void SLsmg_set_color (int c);

      DDeessccrriippttiioonn
        SLsmg_set_color is used to set the current color. The parameter
        c is really a color object descriptor. Actual foreground and
        background colors as well as other visual attributes may be
        associated with a color descriptor via the SLtt_set_color
        function.

      EExxaammppllee
        This example defines color 7 to be green foreground on black
        background and then displays some text in this color:

                SLtt_set_color (7, NULL, "green", "black");
                SLsmg_set_color (7);
                SLsmg_write_string ("Hello");
                SLsmg_refresh ();

      NNootteess
        It is important to understand that the screen managment routines
        know nothing about the actual colors associated with a color
        descriptor. Only the descriptor itself is used by the SLsmg
        routines. The lower level SLtt interface converts the color
        descriptors to actual colors. Thus

                SLtt_set_color (7, NULL, "green", "black");
                SLsmg_set_color (7);
                SLsmg_write_string ("Hello");
                SLtt_set_color (7, NULL, "red", "blue");
                SLsmg_write_string ("World");
                SLsmg_refresh ();

     will result in "hello" displayed in red on blue and _n_o_t green on
     black.

      SSeeee AAllssoo
        SLtt_set_color, SLtt_set_color_object

  44..1111..  SSLLssmmgg__nnoorrmmaall__vviiddeeoo

      SSyynnooppssiiss
        Set the current color to 0

      UUssaaggee
        void SLsmg_normal_video (void);

      DDeessccrriippttiioonn
        SLsmg_normal_video sets the current color descriptor to 0.

      SSeeee AAllssoo
        SLsmg_set_color

  44..1122..  SSLLssmmgg__pprriinnttff

      SSyynnooppssiiss
        Format a string on the virtual display

      UUssaaggee
        void SLsmg_printf (char *fmt, ...)

      DDeessccrriippttiioonn
        SLsmg_printf format a printf style variable argument list and
        writes it on the virtual display. The virtual cursor will be
        moved to the end of the string.

      SSeeee AAllssoo
        SLsmg_write_string, SLsmg_vprintf

  44..1133..  SSLLssmmgg__vvpprriinnttff

      SSyynnooppssiiss
        Format a string on the virtual display

      UUssaaggee
        void SLsmg_vprintf (char *fmt, va_list ap)

      DDeessccrriippttiioonn
        SLsmg_vprintf formats a string in the manner of _v_p_r_i_n_t_f and
        writes the result to the display. The virtual cursor is advanced
        to the end of the string.

      SSeeee AAllssoo
        SLsmg_write_string, SLsmg_printf

  44..1144..  SSLLssmmgg__wwrriittee__ssttrriinngg

      SSyynnooppssiiss
        Write a character string on the display

      UUssaaggee
        void SLsmg_write_string (char *s)

      DDeessccrriippttiioonn
        The function SLsmg_write_string displays the string s on the
        virtual display at the current position and moves the position
        to the end of the string.

      SSeeee AAllssoo
        SLsmg_printf, SLsmg_write_nstring

  44..1155..  SSLLssmmgg__wwrriittee__nnssttrriinngg

      SSyynnooppssiiss
        Write the first n characters of a string on the display

      UUssaaggee
        void SLsmg_write_nstring (char *s, unsigned int n);

      DDeessccrriippttiioonn
        SLsmg_write_nstring writes the first n characters of s to this
        virtual display. If the length of the string s is less than n,
        the spaces will used until n characters have been written. s can
        be NULL, in which case n spaces will be written.

      SSeeee AAllssoo
        SLsmg_write_string, SLsmg_write_nchars

  44..1166..  SSLLssmmgg__wwrriittee__cchhaarr

      SSyynnooppssiiss
        Write a character to the virtual display

      UUssaaggee
        void SLsmg_write_char (char ch);

      DDeessccrriippttiioonn
        SLsmg_write_char writes the character ch to the virtual display.

      SSeeee AAllssoo
        SLsmg_write_nchars, SLsmg_write_string

  44..1177..  SSLLssmmgg__wwrriittee__nncchhaarrss

      SSyynnooppssiiss
        Write n characters to the virtual display

      UUssaaggee
        void SLsmg_write_nchars (char *s, unsigned int n);

      DDeessccrriippttiioonn
        SLsmg_write_nchars writes at most n characters from the string s
        to the display. If the length of s is less than n, the whole
        length of the string will get written.

        This function differs from SLsmg_write_nstring in that
        SLsmg_write_nstring will pad the string to write exactly n
        characters. SLsmg_write_nchars does not perform any padding.

      SSeeee AAllssoo
        SLsmg_write_nchars, SLsmg_write_nstring

  44..1188..  SSLLssmmgg__wwrriittee__wwrraappppeedd__ssttrriinngg

      SSyynnooppssiiss
        Write a string to the display with wrapping

      UUssaaggee
        void SLsmg_write_wrapped_string (s, r, c, nr, nc, fill)

              char *s
              int r, c
              unsigned int nr, nc
              int fill

      DDeessccrriippttiioonn
        SLsmg_write_wrapped_string writes the string s to the virtual
        display. The string will be confined to the rectangular region
        whose upper right corner is at row r and column c, and consists
        of nr rows and nc columns. The string will be wrapped at the
        boundaries of the box. If fill is non-zero, the last line to
        which characters have been written will get padded with spaces.

      NNootteess
        This function does not wrap on word boundaries. However, it will
        wrap when a newline charater is encountered.

      SSeeee AAllssoo
        SLsmg_write_string

  44..1199..  SSLLssmmgg__ccllss

      SSyynnooppssiiss
        Clear the virtual display

      UUssaaggee
        void SLsmg_cls (void)

      DDeessccrriippttiioonn
        SLsmg_cls erases the virtual display using the current color.
        This will cause the physical display to get cleared the next
        time SLsmg_refresh is called.

      NNootteess
        This function is not the same as

               SLsmg_gotorc (0,0); SLsmg_erase_eos ();

     since these statements do not guarantee that the physical screen
     will get cleared.

      SSeeee AAllssoo
        SLsmg_refresh, SLsmg_erase_eos

  44..2200..  SSLLssmmgg__rreeffrreesshh

      SSyynnooppssiiss
        Update physical screen

      UUssaaggee
        void SLsmg_refresh (void)

      DDeessccrriippttiioonn
        The SLsmg_refresh function updates the physical display to look
        like the virtual display.

      SSeeee AAllssoo
        SLsmg_suspend_smg, SLsmg_init_smg, SLsmg_reset_smg

  44..2211..  SSLLssmmgg__ttoouucchh__lliinneess

      SSyynnooppssiiss
        Mark lines on the virtual display for redisplay

      UUssaaggee
        void SLsmg_touch_lines (int r, unsigned int nr)

      DDeessccrriippttiioonn
        SLsmg_touch_lines marks the nr lines on the virtual display
        starting at row r for redisplay upon the next call to
        SLsmg_refresh.

      NNootteess
        This function should rarely be called, if ever. If you find that
        you need to call this function, then your application should be
        modified to properly use the SLsmg screen management routines.
        This function is provided only for curses compatibility.

      SSeeee AAllssoo
        SLsmg_refresh

  44..2222..  SSLLssmmgg__iinniitt__ssmmgg

      SSyynnooppssiiss
        Initialize the SLsmg routines

      UUssaaggee
        int SLsmg_init_smg (void)

      DDeessccrriippttiioonn
        The SLsmg_init_smg function initializes the SLsmg screen
        management routines. Specifically, this function allocates space
        for the virtual display and calls SLtt_init_video to put the
        terminal's physical display in the proper state. It is up to the
        caller to make sure that the SLtt routines are initialized via
        SLtt_get_terminfo before calling SLsmg_init_smg.

        This function should also be called any time the size of the
        physical display has changed so that it can reallocate a new
        virtual display to match the physical display.

        It returns zero upon success, or -1 upon failure.

      SSeeee AAllssoo
        SLsmg_reset_smg

  44..2233..  SSLLssmmgg__rreesseett__ssmmgg

      SSyynnooppssiiss
        Reset the SLsmg routines

      UUssaaggee
        int SLsmg_reset_smg (void);

      DDeessccrriippttiioonn
        SLsmg_reset_smg resets the SLsmg screen management routines by
        freeing all memory allocated while it was active. It also calls
        SLtt_reset_video to put the terminal's display in it default
        state.

      SSeeee AAllssoo
        SLsmg_init_smg

  44..2244..  SSLLssmmgg__cchhaarr__aatt

      SSyynnooppssiiss
        Get the character at the current position on the virtual display

      UUssaaggee
        unsigned short SLsmg_char_at(void)

      DDeessccrriippttiioonn
        The SLsmg_char_at function returns the character and its color
        at the current position on the virtual display.

      SSeeee AAllssoo
        SLsmg_read_raw, SLsmg_write_char

  44..2255..  SSLLssmmgg__sseett__ssccrreeeenn__ssttaarrtt

      SSyynnooppssiiss
        Set the origin of the virtual display

      UUssaaggee
        void SLsmg_set_screen_start (int *r, int *c)

      DDeessccrriippttiioonn
        SLsmg_set_screen_start sets the origin of the virtual display to
        the row *r and the column *c. If either r or c is NULL, then the
        corresponding value will be set to 0.  Otherwise, the location
        specified by the pointers will be updated to reflect the old
        origin.

        See slang/demo/pager.c for how this function may be used to
        scroll horizontally.

      SSeeee AAllssoo
        SLsmg_init_smg

  44..2266..  SSLLssmmgg__ddrraaww__hhlliinnee

      SSyynnooppssiiss
        Draw a horizontal line

      UUssaaggee
        void SLsmg_draw_hline (unsigned int len)

      DDeessccrriippttiioonn
        The SLsmg_draw_hline function draws a horizontal line of length
        len on the virtual display. The position of the virtual cursor
        is left at the end of the line.

      SSeeee AAllssoo
        SLsmg_draw_vline

  44..2277..  SSLLssmmgg__ddrraaww__vvlliinnee

      SSyynnooppssiiss
        Draw a vertical line

      UUssaaggee
        void SLsmg_draw_vline (unsigned int len);

      DDeessccrriippttiioonn
        The SLsmg_draw_vline function draws a vertical line of length
        len on the virtual display. The position of the virtual cursor
        is left at the end of the line.

      SSeeee AAllssoo
        ??

  44..2288..  SSLLssmmgg__ddrraaww__oobbjjeecctt

      SSyynnooppssiiss
        Draw an object from the alternate character set

      UUssaaggee
        void SLsmg_draw_object (int r, int c, unsigned char obj)

      DDeessccrriippttiioonn
        The SLsmg_draw_object function may be used to place the object
        specified by obj at row r and column c. The object is really a
        character from the alternate character set and may be specified
        using one of the following constants:

              SLSMG_HLINE_CHAR         Horizontal line
              SLSMG_VLINE_CHAR         Vertical line
              SLSMG_ULCORN_CHAR        Upper left corner
              SLSMG_URCORN_CHAR        Upper right corner
              SLSMG_LLCORN_CHAR        Lower left corner
              SLSMG_LRCORN_CHAR        Lower right corner
              SLSMG_CKBRD_CHAR         Checkboard character
              SLSMG_RTEE_CHAR          Right Tee
              SLSMG_LTEE_CHAR          Left Tee
              SLSMG_UTEE_CHAR          Up Tee
              SLSMG_DTEE_CHAR          Down Tee
              SLSMG_PLUS_CHAR          Plus or Cross character

      SSeeee AAllssoo
        SLsmg_draw_vline, SLsmg_draw_hline, SLsmg_draw_box

  44..2299..  SSLLssmmgg__ddrraaww__bbooxx

      SSyynnooppssiiss
        Draw a box on the virtual display

      UUssaaggee
        void SLsmg_draw_box (int r, int c, unsigned int dr, unsigned int
        dc)

      DDeessccrriippttiioonn
        SLsmg_draw_box uses the SLsmg_draw_hline and SLsmg_draw_vline
        functions to draw a rectangular box on the virtual display. The
        box's upper left corner is placed at row r and column c. The
        width and length of the box is specified by dc and dr,
        respectively.

      SSeeee AAllssoo
        SLsmg_draw_vline, SLsmg_draw_hline, SLsmg_draw_object

  44..3300..  SSLLssmmgg__sseett__ccoolloorr__iinn__rreeggiioonn

      SSyynnooppssiiss
        Change the color of a specifed region

      UUssaaggee
        void SLsmg_set_color_in_region (color, r, c, dr, dc)

            int color;
            int r, c;
            unsigned int dr, dc;

      DDeessccrriippttiioonn
        SLsmg_set_color_in_region may be used to change the color of a
        rectangular region whose upper left corner is given by (r,c),
        and whose width and height is given by dc and dr, respectively.
        The color of the region is given by the color parameter.

      SSeeee AAllssoo
        SLsmg_draw_box, SLsmg_set_color

  44..3311..  SSLLssmmgg__ggeett__ccoolluummnn

      SSyynnooppssiiss
        Get the column of the virtual cursor

      UUssaaggee
        int SLsmg_get_column(void);

      DDeessccrriippttiioonn
        The SLsmg_get_column function returns the current column of the
        virtual cursor on the virtual display.

      SSeeee AAllssoo
        SLsmg_get_row, SLsmg_gotorc

  44..3322..  SSLLssmmgg__ggeett__rrooww

      SSyynnooppssiiss
        Get the row of the virtual cursor

      UUssaaggee
        int SLsmg_get_row(void);

      DDeessccrriippttiioonn
        The SLsmg_get_row function returns the current row of the
        virtual cursor on the virtual display.

      SSeeee AAllssoo
        SLsmg_get_column, SLsmg_gotorc

  44..3333..  SSLLssmmgg__ffoorrwwaarrdd

      SSyynnooppssiiss
        Move the virtual cursor forward n columns

      UUssaaggee
        void SLsmg_forward (int n);

      DDeessccrriippttiioonn
        The SLsmg_forward function moves the virtual cursor forward n
        columns.

      SSeeee AAllssoo
        SLsmg_gotorc

  44..3344..  SSLLssmmgg__wwrriittee__ccoolloorr__cchhaarrss

      SSyynnooppssiiss
        Write characters with color descriptors to virtual display

      UUssaaggee
        void SLsmg_write_color_chars (unsigned short *s, unsigned int
        len)

      DDeessccrriippttiioonn
        The SLsmg_write_color_chars function may be used to write len
        characters, each with a different color descriptor to the
        virtual display. Each character and its associated color are
        encoded as an unsigned short such that the lower eight bits form
        the character and the next eight bits form the color.

      SSeeee AAllssoo
        SLsmg_char_at, SLsmg_write_raw

  44..3355..  SSLLssmmgg__rreeaadd__rraaww

      SSyynnooppssiiss
        Read characters from the virtual display

      UUssaaggee
        unsigned int SLsmg_read_raw (unsigned short *buf, unsigned int
        len)

      DDeessccrriippttiioonn
        SLsmg_read_raw attempts to read len characters from the current
        position on the virtual display into the buffer specified by
        buf. It returns the number of characters actually read. This
        number will be less than len if an attempt is made to read past
        the right margin of the display.

      NNootteess
        The purpose of the pair of functions, SLsmg_read_raw and
        SLsmg_write_raw, is to permit one to copy the contents of one
        region of the virtual display to another region.

      SSeeee AAllssoo
        SLsmg_char_at, SLsmg_write_raw

  44..3366..  SSLLssmmgg__wwrriittee__rraaww

      SSyynnooppssiiss
        Write characters directly to the virtual display

      UUssaaggee
        unsigned int SLsmg_write_raw (unsigned short *buf, unsigned int
        len)

      DDeessccrriippttiioonn
        The SLsmg_write_raw function attempts to write len characters
        specified by buf to the display at the current position. It
        returns the number of characters successfully written, which
        will be less than len if an attempt is made to write past the
        right margin.

      NNootteess
        The purpose of the pair of functions, SLsmg_read_raw and
        SLsmg_write_raw, is to permit one to copy the contents of one
        region of the virtual display to another region.

      SSeeee AAllssoo
        SLsmg_read_raw

  55..  FFuunnccttiioonnss tthhaatt ddeeaall wwiitthh tthhee iinntteerrpprreetteerr

  55..11..  SSLLaallllooccaattee__llooaadd__ttyyppee

      SSyynnooppssiiss
        Allocate a SLang_Load_Type object

      UUssaaggee
        SLang_Load_Type *SLallocate_load_type (char *name)

      DDeessccrriippttiioonn
        The SLallocate_load_type function allocates and initializes
        space for a SLang_Load_Type object and returns it. Upon failure,
        the function returns NULL. The parameter name must uniquely
        identify the object. For example, if the object represents a
        file, then name could be the absolute path name of the file.

      SSeeee AAllssoo
        SLdeallocate_load_type, SLang_load_object

  55..22..  SSLLddeeaallllooccaattee__llooaadd__ttyyppee

      SSyynnooppssiiss
        Free a SLang_Load_Type object

      UUssaaggee
        void SLdeallocate_load_type (SLang_Load_Type *slt)

      DDeessccrriippttiioonn
        This function frees the memory associated with a SLang_Load_Type
        object that was acquired from a call to the SLallocate_load_type
        function.

      SSeeee AAllssoo
        SLallocate_load_type, SLang_load_object

  55..33..  SSLLaanngg__llooaadd__oobbjjeecctt

      SSyynnooppssiiss
        Load an object into the interpreter

      UUssaaggee
        int SLang_load_object (SLang_Load_Type *obj)
      DDeessccrriippttiioonn
        The function SLang_load_object is a generic function that may be
        used to loaded an object of type SLang_Load_Type into the
        interpreter. For example, the functions SLang_load_file and
        SLang_load_string are wrappers around this function to load a
        file and a string, respectively.

      SSeeee AAllssoo
        SLang_load_file, SLang_load_string, SLallocate_load_type

  55..44..  SSLLccllaassss__aallllooccaattee__ccllaassss

      SSyynnooppssiiss
        Allocate a class for a new data type

      UUssaaggee
        SLang_Class_Type *SLclass_allocate_class (char *name)

      DDeessccrriippttiioonn
        The purpose of this function is to allocate and initialize space
        that defines a new data type or class called name. If
        successful, a pointer to the class is returned, or upon failure
        the function returns NULL.

        This function does not automatically create the new data type.
        Callback functions must first be associated with the data type
        via functions such as SLclass_set_push_function, and the data
        type must be registered with the interpreter via
        SLclass_register_class. See the SS--LLaanngg library programmer's
        guide for more information.

      SSeeee AAllssoo
        SLclass_register_class, SLclass_set_push_function

  55..55..  SSLLccllaassss__rreeggiisstteerr__ccllaassss

      SSyynnooppssiiss
        Register a new data type with the interpreter

      UUssaaggee
        int SLclass_register_class (cl, type, sizeof_type, class_type)

              SLang_Class_Type *cl
              SLtype type
              unsigned int sizeof_type
              SLclass_Type class_type

      DDeessccrriippttiioonn
        The SLclass_register_class function is used to register a new
        class or data type with the interpreter. If successful, the
        function returns 0, or upon failure, it returns -1.

        The first parameter, cl, must have been previously obtained via
        the SLclass_allocate_class function.
        The second parameter, type specifies the data type of the new
        class. If set to SLANG_VOID_TYPE then the library will
        automatically allocate an unused value for the class (the
        allocated value can then be found using the SLclass_get_class_id
        function), otherwise a value greater than 255 should be used.
        The values in the range 0-255 are reserved for internal use by
        the library.

        The size that the data type represents in bytes is specified by
        the third parameter, sizeof_type. This value should not be
        confused with the sizeof the structure that represents the data
        type, unless the data type is of class SLANG_CLASS_TYPE_VECTOR
        or SLANG_CLASS_TYPE_SCALAR. For pointer objects, the value of
        this parameter is just sizeof(void *).

        The final parameter specifies the class type of the data type.
        It must be one of the values:

               SLANG_CLASS_TYPE_SCALAR
               SLANG_CLASS_TYPE_VECTOR
               SLANG_CLASS_TYPE_PTR
               SLANG_CLASS_TYPE_MMT

     The SLANG_CLASS_TYPE_SCALAR indicates that the new data type is a
     scalar. Examples of scalars in SLANG_INT_TYPE and SLANG_DOU-
     BLE_TYPE.

     Setting class_type to SLANG_CLASS_TYPE_VECTOR implies that the new
     data type is a vector, or a 1-d array of scalar types. An example
     of a data type of this class is the SLANG_COMPLEX_TYPE, which
     represents complex numbers.

     SLANG_CLASS_TYPE_PTR specifies the data type is of a pointer type.
     Examples of data types of this class include SLANG_STRING_TYPE and
     SLANG_ARRAY_TYPE. Such types must provide for their own memory
     management.

     Data types of class SLANG_CLASS_TYPE_MMT are pointer types except
     that the memory management, i.e., creation and destruction of the
     type, is handled by the interpreter. Such a type is called a _m_e_m_o_r_y
     _m_a_n_a_g_e_d _t_y_p_e. An example of this data type is the
     SLANG_FILEPTR_TYPE.

      NNootteess
        See the _S_-_L_a_n_g _L_i_b_r_a_r_y _C _P_r_o_g_r_a_m_m_e_r_'_s _G_u_i_d_e for more
        information.

      SSeeee AAllssoo
        SLclass_allocate_class, SLclass_get_class_id

  55..66..  SSLLccllaassss__sseett__ssttrriinngg__ffuunnccttiioonn

      SSyynnooppssiiss
        Set a data type's string representation callback

      UUssaaggee
        int SLclass_set_string_function (cl, sfun)

        SLang_Class_Type *cl
        char *(*sfun) (SLtype, VOID_STAR);

      DDeessccrriippttiioonn
        The SLclass_set_string_function routine is used to define a
        callback function, sfun, that will be used when a string
        representation of an object of the data type represented by cl
        is needed. cl must have already been obtained via a call to
        SLclass_allocate_class. When called, sfun will be passed two
        arguments: an SLtype which represents the data type, and the
        address of the object for which a string represetation is
        required. The callback function must return a _m_a_l_l_o_c_e_d string.

        Upon success, SLclass_set_string_function returns zero, or upon
        error it returns -1.

      EExxaammppllee
        A callback function that handles both SLANG_STRING_TYPE and
        SLANG_INT_TYPE variables looks like:

               char *string_and_int_callback (SLtype type, VOID_STAR addr)
               {
                  char buf[64];

                  switch (type)
                    {
                     case SLANG_STRING_TYPE:
                       return SLmake_string (*(char **)addr);

                     case SLANG_INTEGER_TYPE:
                       sprintf (buf, "%d", *(int *)addr);
                       return SLmake_string (buf);
                    }
                  return NULL;
               }

      NNootteess
        The default string callback simply returns the name of the data
        type.

      SSeeee AAllssoo
        SLclass_allocate_class, SLclass_register_class

  55..77..  SSLLccllaassss__sseett__ddeessttrrooyy__ffuunnccttiioonn

      SSyynnooppssiiss
        Set the destroy method callback for a data type

      UUssaaggee
        int SLclass_set_destroy_function (cl, destroy_fun)

              SLang_Class_Type *cl
              void (*destroy_fun) (SLtype, VOID_STAR);

      DDeessccrriippttiioonn
        SLclass_set_destroy_function is used to set the destroy callback
        for a data type. The data type's class cl must have been
        previously obtained via a call to SLclass_allocate_class.  When
        called, destroy_fun will be passed two arguments: an SLtype
        which represents the data type, and the address of the object to
        be destroyed.

        SLclass_set_destroy_function returns zero upon success, and -1
        upon failure.

      EExxaammppllee
        The destroy method for SLANG_STRING_TYPE looks like:

              static void string_destroy (SLtype type, VOID_STAR ptr)
              {
                 char *s = *(char **) ptr;
                 if (s != NULL) SLang_free_slstring (*(char **) s);
              }

      NNootteess
        Data types of class SLANG_CLASS_TYPE_SCALAR do not require a
        destroy callback. However, other classes do.

      SSeeee AAllssoo
        SLclass_allocate_class, SLclass_register_class

  55..88..  SSLLccllaassss__sseett__ppuusshh__ffuunnccttiioonn

      SSyynnooppssiiss
        Set the push callback for a new data type

      UUssaaggee
        int SLclass_set_push_function (cl, push_fun)

              SLang_Class_Type *cl
              int (*push_fun) (SLtype, VOID_STAR);

      DDeessccrriippttiioonn
        SLclass_set_push_function is used to set the push callback for a
        new data type specified by cl, which must have been previously
        obtained via SLclass_allocate_class.

        The parameter push_fun is a pointer to the push callback. It is
        required to take two arguments: an SLtype representing the data
        type, and the address of the object to be pushed. It must return
        zero upon success, or -1 upon failure.

        SLclass_set_push_function returns zero upon success, or -1 upon
        failure.

      EExxaammppllee
        The push callback for SLANG_COMPLEX_TYPE looks like:

           static int complex_push (SLtype type, VOID_STAR ptr)
           {
              double *z = *(double **) ptr;
              return SLang_push_complex (z[0], z[1]);
           }

      SSeeee AAllssoo
        SLclass_allocate_class, SLclass_register_class

  55..99..  SSLLccllaassss__sseett__ppoopp__ffuunnccttiioonn

      SSyynnooppssiiss
        Set the pop callback for a new data type

      UUssaaggee
        int SLclass_set_pop_function (cl, pop_fun)

              SLang_Class_Type *cl
              int (*pop_fun) (SLtype, VOID_STAR);

      DDeessccrriippttiioonn
        SLclass_set_pop_function is used to set the callback for popping
        an object from the stack for a new data type specified by cl,
        which must have been previously obtained via
        SLclass_allocate_class.

        The parameter pop_fun is a pointer to the pop callback function,
        which is required to take two arguments: an unsigned character
        representing the data type, and the address of the object to be
        popped. It must return zero upon success, or -1 upon failure.

        SLclass_set_pop_function returns zero upon success, or -1 upon
        failure.

      EExxaammppllee
        The pop callback for SLANG_COMPLEX_TYPE looks like:

                static int complex_push (SLtype type, VOID_STAR ptr)
                {
                   double *z = *(double **) ptr;
                   return SLang_pop_complex (&z[0], &z[1]);
                }

      SSeeee AAllssoo
        SLclass_allocate_class, SLclass_register_class

  55..1100..  SSLLccllaassss__ggeett__ddaattaattyyppee__nnaammee

      SSyynnooppssiiss
        Get the name of a data type

      UUssaaggee
        char *SLclass_get_datatype_name (SLtype type)

      DDeessccrriippttiioonn
        The SLclass_get_datatype_name function returns the name of the
        data type specified by type. For example, if type is
        SLANG_INT_TYPE, the string "Integer_Type" will be returned.

        This function returns a pointer that should not be modified or
        freed.

      SSeeee AAllssoo
        SLclass_allocate_class, SLclass_register_class

  55..1111..  SSLLaanngg__ffrreeee__mmmmtt

      SSyynnooppssiiss
        Free a memory managed type

      UUssaaggee
        void SLang_free_mmt (SLang_MMT_Type *mmt)

      DDeessccrriippttiioonn
        The SLang_MMT_Type function is used to free a memory managed
        data type.

      SSeeee AAllssoo
        SLang_object_from_mmt, SLang_create_mmt

  55..1122..  SSLLaanngg__oobbjjeecctt__ffrroomm__mmmmtt

      SSyynnooppssiiss
        Get a pointer to the value of a memory managed type

      UUssaaggee
        VOID_STAR SLang_object_from_mmt (SLang_MMT_Type *mmt)

      DDeessccrriippttiioonn
        The SLang_object_from_mmt function returns a pointer to the
        actual object whose memory is being managed by the interpreter.

      SSeeee AAllssoo
        SLang_free_mmt, SLang_create_mmt

  55..1133..  SSLLaanngg__ccrreeaattee__mmmmtt

      SSyynnooppssiiss
        Create a memory managed data type

      UUssaaggee
        SLang_MMT_Type *SLang_create_mmt (SLtype t, VOID_STAR ptr)

      DDeessccrriippttiioonn
        The SLang_create_mmt function returns a pointer to a new memory
        managed object. This object contains information necessary to
        manage the memory associated with the pointer ptr which
        represents the application defined data type of type t.

      SSeeee AAllssoo
        SLang_object_from_mmt, SLang_push_mmt, SLang_free_mmt

  55..1144..  SSLLaanngg__ppuusshh__mmmmtt

      SSyynnooppssiiss
        Push a memory managed type

      UUssaaggee
        int SLang_push_mmt (SLang_MMT_Type *mmt)

      DDeessccrriippttiioonn
        This function is used to push a memory managed type onto the
        interpreter stack. It returns zero upon success, or -1 upon
        failure.

      SSeeee AAllssoo
        SLang_create_mmt, SLang_pop_mmt

  55..1155..  SSLLaanngg__ppoopp__mmmmtt

      SSyynnooppssiiss
        Pop a memory managed data type

      UUssaaggee
        SLang_MMT_Type *SLang_pop_mmt (SLtype t)

      DDeessccrriippttiioonn
        The SLang_pop_mmt function may be used to pop a memory managed
        type of type t from the stack. It returns a pointer to the
        memory managed object upon success, or NULL upon failure. The
        function SLang_object_from_mmt should be used to access the
        actual pointer to the data type.

      SSeeee AAllssoo
        SLang_object_from_mmt, SLang_push_mmt

  55..1166..  SSLLaanngg__iinncc__mmmmtt

      SSyynnooppssiiss
        Increment a memory managed type reference count

      UUssaaggee
        void SLang_inc_mmt (SLang_MMT_Type *mmt);

      DDeessccrriippttiioonn
        The SLang_inc_mmt function may be used to increment the
        reference count associated with the memory managed data type
        given by mmt.

      SSeeee AAllssoo
        SLang_free_mmt, SLang_create_mmt, SLang_pop_mmt, SLang_pop_mmt

  55..1177..  SSLLaadddd__iinnttrriinn__ffuunn__ttaabbllee

      SSyynnooppssiiss
        Add a table of intrinsic functions to the interpreter

      UUssaaggee
        int SLadd_intrin_fun_table(SLang_Intrin_Fun_Type *tbl, char
        *pp_name);

      DDeessccrriippttiioonn
        The SLadd_intrin_fun_table function adds an array, or table, of
        SLang_Intrin_Fun_Type objects to the interpreter. The first
        parameter, tbl specifies the table to be added. The second
        parameter pp_name, if non-NULL will be added to the list of
        preprocessor symbols.

        This function returns -1 upon failure or zero upon success.

      NNootteess
        A table should only be loaded one time and it is considered to
        be an error on the part of the application if it loads a table
        more than once.

      SSeeee AAllssoo
        SLadd_intrin_var_table, SLadd_intrinsic_function,
        SLdefine_for_ifdef

  55..1188..  SSLLaadddd__iinnttrriinn__vvaarr__ttaabbllee

      SSyynnooppssiiss
        Add a table of intrinsic variables to the interpreter

      UUssaaggee
        int SLadd_intrin_var_table (SLang_Intrin_Var_Type *tbl, char
        *pp_name);

      DDeessccrriippttiioonn
        The SLadd_intrin_var_table function adds an array, or table, of
        SLang_Intrin_Var_Type objects to the interpreter. The first
        parameter, tbl specifies the table to be added. The second
        parameter pp_name, if non-NULL will be added to the list of
        preprocessor symbols.

        This function returns -1 upon failure or zero upon success.

      NNootteess
        A table should only be loaded one time and it is considered to
        be an error on the part of the application if it loads a table
        more than once.

      SSeeee AAllssoo
        SLadd_intrin_var_table, SLadd_intrinsic_function,
        SLdefine_for_ifdef

  55..1199..  SSLLaanngg__llooaadd__ffiillee

      SSyynnooppssiiss
        Load a file into the interpreter

      UUssaaggee
        int SLang_load_file (char *fn)

      DDeessccrriippttiioonn
        The SLang_load_file function opens the file whose name is
        specified by fn and feeds it to the interpreter, line by line,
        for execution. If fn is NULL, the function will take input from
        stdin.

        If no error occurs, it returns 0; otherwise, it returns -1, and
        sets SLang_Error accordingly. For example, if it fails to open
        the file, it will return -1 with SLang_Error set to
        SL_OBJ_NOPEN.

      NNootteess
        If the hook SLang_Load_File_Hook declared as

                int (*SLang_Load_File_Hook)(char *);

     is non-NULL, the function point to by it will be used to load the
     file. For example, the jjeedd editor uses this hook to load files via
     its own routines.

      SSeeee AAllssoo
        SLang_load_object, SLang_load_string

  55..2200..  SSLLaanngg__rreessttaarrtt

      SSyynnooppssiiss
        Reset the interpreter after an error

      UUssaaggee
        void SLang_restart (int full)

      DDeessccrriippttiioonn
        The SLang_restart function should be called by the application
        at top level if an error occurs. If the parameter full is non-
        zero, any objects on the SS--LLaanngg run time stack will be removed
        from the stack; otherwise, the stack will be left intact. Any
        time the stack is believed to be trashed, this routine should be
        called with a non-zero argument (e.g., if setjmp/longjmp is
        called).

        Calling SLang_restart does not reset the global variable
        SLang_Error to zero. It is up to the application to reset that
        variable to zero after calling SLang_restart.

      EExxaammppllee

                while (1)
                  {
                     if (SLang_Error)
                       {
                          SLang_restart (1);
                          SLang_Error = 0;
                       }
                     (void) SLang_load_file (NULL);
                  }

      SSeeee AAllssoo
        SLang_init_slang, SLang_load_file

  55..2211..  SSLLaanngg__bbyyttee__ccoommppiillee__ffiillee

      SSyynnooppssiiss
        Byte-compile a file for faster loading

      UUssaaggee
        int SLang_byte_compile_file(char *fn, int reserved)

      DDeessccrriippttiioonn
        The SLang_byte_compile_file function ``byte-compiles'' the file
        fn for faster loading by the interpreter. This produces a new
        file whose filename is equivalent to the one specified by fn,
        except that a 'c' is appended to the name. For example, if fn is
        set to init.sl, then the new file will have the name
        exmp{init.slc}. The meaning of the second parameter, reserved,
        is reserved for future use. For now, set it to 0.

        The function returns zero upon success, or -1 upon error and
        sets SLang_Error accordingly.

      SSeeee AAllssoo
        SLang_load_file, SLang_init_slang

  55..2222..  SSLLaanngg__aauuttoollooaadd

      SSyynnooppssiiss
        Autoload a function from a file

      UUssaaggee
        int SLang_autoload(char *funct, char *filename)

      DDeessccrriippttiioonn
        The SLang_autoload function may be used to associate a slang
        function name funct with the file filename such that if funct
        has not already been defined when needed, it will be loaded from
        filename.

        SLang_autoload has no effect if funct has already been defined.
        Otherwise it declares funct as a user-defined SS--LLaanngg function.
        It returns 0 upon success, or -1 upon error.

      SSeeee AAllssoo
        SLang_load_file, SLang_is_defined

  55..2233..  SSLLaanngg__llooaadd__ssttrriinngg

      SSyynnooppssiiss
        Interpret a string

      UUssaaggee
        int SLang_load_string(char *str)

      DDeessccrriippttiioonn
        The SLang_load_string function feeds the string specified by str
        to the interpreter for execution. It returns zero upon success,
        or -1 upon failure.

      SSeeee AAllssoo
        SLang_load_file, SLang_load_object

  55..2244..  SSLLddoo__ppoopp

      SSyynnooppssiiss
        Delete an object from the stack

      UUssaaggee
        int SLdo_pop(void)

      DDeessccrriippttiioonn
        This function removes an object from the top of the interpeter's
        run-time stack and frees any memory associated with it. It
        returns zero upon success, or -1 upon error (most likely due to
        a stack-underflow).

      SSeeee AAllssoo
        SLdo_pop_n, SLang_pop_integer, SLang_pop_string

  55..2255..  SSLLddoo__ppoopp__nn

      SSyynnooppssiiss
        Delete n objects from the stack

      UUssaaggee
        int SLdo_pop_n (unsigned int n)

      DDeessccrriippttiioonn
        The SLdo_pop_n function removes the top n objects from the
        interpreter's run-time stack and frees all memory associated
        with the objects. It returns zero upon success, or -1 upon error
        (most likely due to a stack-underflow).

      SSeeee AAllssoo
        SLdo_pop, SLang_pop_integer, SLang_pop_string

  55..2266..  SSLLaanngg__ppoopp__iinntteeggeerr

      SSyynnooppssiiss
        Pop an integer off the stack

      UUssaaggee
        int SLang_pop_integer (int *i)

      DDeessccrriippttiioonn
        The SLang_pop_integer function removes an integer from the top
        of the interpreter's run-time stack and returns its value via
        the pointer i. If successful, it returns zero. However, if the
        top stack item is not of type SLANG_INT_TYPE, or the stack is
        empty, the function will return -1 and set SLang_Error
        accordingly.

      SSeeee AAllssoo
        SLang_push_integer, SLang_pop_double

  55..2277..  SSLLppoopp__ssttrriinngg

      SSyynnooppssiiss
        Pop a string from the stack

      UUssaaggee
        int SLpop_string (char **strptr);

      DDeessccrriippttiioonn
        The SLpop_string function pops a string from the stack and
        returns it as a malloced pointer. It is up to the calling
        routine to free this string via a call to free or SLfree. If
        successful, SLpop_string returns zero. However, if the top stack
        item is not of type SLANG_STRING_TYPE, or the stack is empty,
        the function will return -1 and set SLang_Error accordingly.

      EExxaammppllee

                define print_string (void)
                {
                   char *s;
                   if (-1 == SLpop_string (&s))
                     return;
                   fputs (s, stdout);
                   SLfree (s);
                }

      NNootteess
        This function should not be confused with SLang_pop_slstring,
        which pops a _h_a_s_h_e_d string from the stack.

      SSeeee AAllssoo
        SLang_pop_slstring. SLfree

  55..2288..  SSLLaanngg__ppoopp__ssttrriinngg

      SSyynnooppssiiss
        Pop a string from the stack

      UUssaaggee
        int SLang_pop_string(char **strptr, int *do_free)

      DDeessccrriippttiioonn
        The SLpop_string function pops a string from the stack and
        returns it as a malloced pointer via strptr. After the function
        returns, the integer pointed to by the second parameter will be
        set to a non-zero value if *strptr should be freed via free or
        SLfree. If successful, SLpop_string returns zero. However, if
        the top stack item is not of type SLANG_STRING_TYPE, or the
        stack is empty, the function will return -1 and set SLang_Error
        accordingly.

      NNootteess
        This function is considered obsolete and should not be used by
        applications. If one requires a malloced string for
        modification, SLpop_string should be used. If one requires a
        constant string that will not be modifed by the application,
        SLang_pop_slstring should be used.

      SSeeee AAllssoo
        SLang_pop_slstring, SLpop_string

  55..2299..  SSLLaanngg__ppoopp__ssllssttrriinngg

      SSyynnooppssiiss
        Pop a hashed string from the stack

      UUssaaggee
        int SLang_pop_slstring (char **s_ptr)

      DDeessccrriippttiioonn
        The SLang_pop_slstring function pops a hashed string from the SS--
        LLaanngg run-time stack and returns it via s_ptr. It returns zero if
        successful, or -1 upon failure. The resulting string should be
        freed via a call to SLang_free_slstring after use.

      EExxaammppllee

             void print_string (void)
             {
                char *s;
                if (-1 == SLang_pop_slstring (&s))
                  return;
                fprintf (stdout, "%s\n", s);
                SLang_free_slstring (s);
             }

      NNootteess
        SLang_free_slstring is the preferred function for popping
        strings. This is a result of the fact that the interpreter uses
        hashed strings as the native representation for string data.

        One must _n_e_v_e_r free a hashed string using free or SLfree. In
        addition, one must never make any attempt to modify a hashed
        string and doing so will result in memory corruption.

      SSeeee AAllssoo
        SLang_free_slstring, SLpop_string

  55..3300..  SSLLaanngg__ppoopp__ddoouubbllee

      SSyynnooppssiiss
        Pop a double from the stack

      UUssaaggee
        int SLang_pop_double (double *dptr)

      DDeessccrriippttiioonn
        The SLang_pop_double function pops a double precision number
        from the stack and returns it via dptr. This function returns 0
        upon success, otherwise it returns -1 and sets SLang_Error
        accordingly.

      SSeeee AAllssoo
        SLang_pop_integer, SLang_push_double

  55..3311..  SSLLaanngg__ppoopp__ccoommpplleexx

      SSyynnooppssiiss
        Pop a complex number from the stack

      UUssaaggee
        int SLang_pop_complex (double *re, double *im)

      DDeessccrriippttiioonn
        SLang_pop_complex pops a complex number from the stack and
        returns it via the parameters re and im as the real and
        imaginary parts of the complex number, respectively. This
        function automatically converts objects of type
        SLANG_DOUBLE_TYPE and SLANG_INT_TYPE to SLANG_COMPLEX_TYPE, if
        necessary.  It returns zero upon success, or -1 upon error
        setting SLang_Error accordingly.

      SSeeee AAllssoo
        SLang_pop_integer, SLang_pop_double, SLang_push_complex

  55..3322..  SSLLaanngg__ppuusshh__ccoommpplleexx

      SSyynnooppssiiss
        Push a complex number onto the stack

      UUssaaggee
        int SLang_push_complex (double re, double im)

      DDeessccrriippttiioonn
        SLang_push_complex may be used to push the complex number whose
        real and imaginary parts are given by re and im, respectively.
        It returns zero upon success, or -1 upon error setting
        SLang_Error accordingly.

      SSeeee AAllssoo
        SLang_pop_complex, SLang_push_double

  55..3333..  SSLLaanngg__ppuusshh__ddoouubbllee

      SSyynnooppssiiss
        Push a double onto the stack

      UUssaaggee
        int SLang_push_double(double d)

      DDeessccrriippttiioonn
        SLang_push_double may be used to push the double precision
        floating point number d onto the interpreter's run-time stack.
        It returns zero upon success, or -1 upon error setting
        SLang_Error accordingly.

      SSeeee AAllssoo
        SLang_pop_double, SLang_push_integer

  55..3344..  SSLLaanngg__ppuusshh__ssttrriinngg

      SSyynnooppssiiss
        Push a string onto the stack

      UUssaaggee
        int SLang_push_string (char *s)

      DDeessccrriippttiioonn
        SLang_push_string pushes a copy of the string specified by s
        onto the interpreter's run-time stack. It returns zero upon
        success, or -1 upon error setting SLang_Error accordingly.

      NNootteess
        If s is NULL, this function pushes NULL (SLANG_NULL_TYPE) onto
        the stack.

      SSeeee AAllssoo
        SLang_push_malloced_string

  55..3355..  SSLLaanngg__ppuusshh__iinntteeggeerr

      SSyynnooppssiiss
        Push an integer onto the stack

      UUssaaggee
        int SLang_push_integer (int i)

      DDeessccrriippttiioonn
        SLang_push_integer the integer i onto the interpreter's run-time
        stack. It returns zero upon success, or -1 upon error setting
        SLang_Error accordingly.

      SSeeee AAllssoo
        SLang_pop_integer, SLang_push_double, SLang_push_string

  55..3366..  SSLLaanngg__ppuusshh__mmaalllloocceedd__ssttrriinngg

      SSyynnooppssiiss
        Push a malloced string onto the stack

      UUssaaggee
        int SLang_push_malloced_string (char *s);

      DDeessccrriippttiioonn
        SLang_push_malloced_string may be used to push a malloced string
        onto the interpreter's run-time stack. It returns zero upon
        success, or -1 upon error setting SLang_Error accordingly.

      EExxaammppllee
        The following example illustrates that it is up to the calling
        routine to free the string if SLang_push_malloced_string fails:

                int push_hello (void)
                {
                   char *s = malloc (6);
                   if (s == NULL) return -1;
                   strcpy (s, "hello");
                   if (-1 == SLang_push_malloced_string (s))
                     {
                        free (s);
                        return -1;
                     }
                   return 0;
                }

      EExxaammppllee
        The function SLang_create_slstring returns a hashed string.
        Such a string may not be malloced and should not be passed to
        SLang_push_malloced_string.

      NNootteess
        If s is NULL, this function pushes NULL (SLANG_NULL_TYPE) onto
        the stack.

      SSeeee AAllssoo
        SLang_push_string, SLmake_string

  55..3377..  SSLLaanngg__iiss__ddeeffiinneedd

      SSyynnooppssiiss
        Check to see if the interpreter defines an object

      UUssaaggee
        int SLang_is_defined (char *nm)

      DDeessccrriippttiioonn
        The SLang_is_defined function may be used to determine whether
        or not a variable or function whose name is given by em has been
        defined. It returns zero if no such object has been defined.
        Otherwise it returns a non-zero value according to the following
        table:

                1    intrinsic function
                2    user-defined slang function
               -1    intrinsic variable
               -2    user-defined global variable

     Note that variables correspond to negative numbers and functions
     are represented by positive numbers.

      SSeeee AAllssoo
        SLadd_intrinsic_function, SLang_run_hooks,
        SLang_execute_function

  55..3388..  SSLLaanngg__rruunn__hhooookkss

      SSyynnooppssiiss
        Run a user-defined hook with arguments

      UUssaaggee
        int SLang_run_hooks (char *fname, unsigned int n, ...)

      DDeessccrriippttiioonn
        The SLang_run_hooks function may be used to execute a user-
        defined function named fname. Before execution of the function,
        the n string arguments specified by the variable parameter list
        are pushed onto the stack. If the function fname does not exist,
        SLang_run_hooks returns zero; otherwise, it returns 1 upon
        successful execution of the function, or -1 if an error
        occurred.

      EExxaammppllee
        The jjeedd editor uses SLang_run_hooks to setup the mode of a
        buffer based on the filename extension of the file associated
        with the buffer:

                char *ext = get_filename_extension (filename);
                if (ext == NULL) return -1;
                if (-1 == SLang_run_hooks ("mode_hook", 1, ext))
                  return -1;
                return 0;

      SSeeee AAllssoo
        SLang_is_defined, SLang_execute_function

  55..3399..  SSLLaanngg__eexxeeccuuttee__ffuunnccttiioonn

      SSyynnooppssiiss
        Execute a user or intrinsic function

      UUssaaggee
        int SLang_execute_function (char *fname)

      DDeessccrriippttiioonn
        This function may be used to execute either a user-defined
        function or an intrinisic function. The name of the function is
        specified by fname. It returns zero if fname is not defined, or
        1 if the function was successfully executed, or -1 upon error.

      NNootteess
        The function SLexecute_function may be a better alternative for
        some uses.

      SSeeee AAllssoo
        SLang_run_hooks, SLexecute_function, SLang_is_defined

  55..4400..  SSLLaanngg__ggeett__ffuunnccttiioonn

      SSyynnooppssiiss
        Get a pointer to a SS--LLaanngg function

      UUssaaggee
        SLang_Name_Type *SLang_get_function (char *fname)

      DDeessccrriippttiioonn
        This function returns a pointer to the internal SS--LLaanngg table
        entry of a function whose name is given by fname. It returns
        NULL upon failure. The value returned by this function can be
        used SLexecute_function to call the function directly from C.

      SSeeee AAllssoo
        SLexecute_function

  55..4411..  SSLLeexxeeccuuttee__ffuunnccttiioonn

      SSyynnooppssiiss
        Execute a SS--LLaanngg or intrinsic function

      UUssaaggee
        int SLexecute_function (SLang_Name_Type *nt)

      DDeessccrriippttiioonn
        The SLexecute_function allows an application to call the SS--LLaanngg
        function specified by the SLang_Name_Type pointer nt. This
        parameter must be non NULL and must have been previously
        obtained by a call to SLang_get_function.
      EExxaammppllee
        Consider the SS--LLaanngg function:

               define my_fun (x)
               {
                  return x^2 - 2;
               }

     Suppose that it is desired to call this function many times with
     different values of x. There are at least two ways to do this.  The
     easiest way is to use SLang_execute_function by passing the string
     "my_fun". A better way that is much faster is to use SLexe-
     cute_function:

                int sum_a_function (char *fname, double *result)
                {
                   double sum, x, y;
                   SLang_Name_Type *nt;

                   if (NULL == (nt = SLang_get_function (fname)))
                     return -1;

                   sum = 0;
                   for (x = 0; x < 10.0; x += 0.1)
                     {
                        SLang_start_arg_list ();
                        if (-1 == SLang_push_double (x))
                          return -1;
                        SLang_end_arg_list ();
                        if (-1 == SLexecute_function (nt))
                          return -1;
                        if (-1 == SLang_pop_double (&y))
                          return -1;

                        sum += y;
                     }
                   return sum;
                }

     Although not necessary in this case, SLang_start_arg_list and
     SLang_end_arg_list were used to provide the function with informa-
     tion about the number of parameters passed to it.

      SSeeee AAllssoo
        SLang_get_function, SLang_start_arg_list, SLang_end_arg_list

  55..4422..  SSLLaanngg__ppeeeekk__aatt__ssttaacckk

      SSyynnooppssiiss
        Find the type of object on the top of the stack

      UUssaaggee
        int SLang_peek_at_stack (void)

      DDeessccrriippttiioonn
        The SLang_peek_at_stack function is useful for determining the
        data type of the object at the top of the stack. It returns the
        data type, or -1 upon a stack-underflow error. It does not
        remove anything from the stack.

      SSeeee AAllssoo
        SLang_pop_string, SLang_pop_integer

  55..4433..  SSLLaanngg__ppoopp__ffiilleeppttrr

      SSyynnooppssiiss
        Pop a file pointer

      UUssaaggee
        int SLang_pop_fileptr (SLang_MMT_Type **mmt, FILE **fp)

      DDeessccrriippttiioonn
        SLang_pop_fileptr pops a file pointer from the SS--LLaanngg run-time
        stack. It returns zero upon success, or -1 upon failure.

        A SS--LLaanngg file pointer (SLANG_FILEPTR_TYPE) is actually a memory
        managed object. For this reason, SLang_pop_fileptr also returns
        the memory managed object via the argument list. It is up to the
        calling routine to call SLang_free_mmt to free the object.

      EExxaammppllee
        The following example illustrates an application defined
        intrinsic function that writes a user defined double precision
        number to a file. Note the use of SLang_free_mmt:

               int write_double (void)
               {
                  double t;
                  SLang_MMT_Type *mmt;
                  FILE *fp;
                  int status;

                  if (-1 == SLang_pop_double (&d, NULL, NULL))
                    return -1;
                  if (-1 == SLang_pop_fileptr (&mmt, &fp))
                    return -1;

                  status = fwrite (&d, sizeof (double), 1, fp);
                  SLang_free_mmt (mmt);
                  return status;
               }

     This function can be used by a SS--LLaanngg function as follows:

          define write_some_values ()
          {
             variable fp, d;

             fp = fopen ("myfile.dat", "wb");
             if (fp == NULL)
               error ("file failed to open");
             for (d = 0; d < 10.0; d += 0.1)
               {
                  if (-1 == write_double (fp, d))
                    error ("write failed");
               }
             if (-1 == fclose (fp))
               error ("fclose failed");
          }

      SSeeee AAllssoo
        SLang_free_mmt, SLang_pop_double

  55..4444..  SSLLaadddd__iinnttrriinnssiicc__ffuunnccttiioonn

      SSyynnooppssiiss
        Add a new intrinsic function to the interpreter

      UUssaaggee
        int SLadd_intrinsic_function (name, f, type, nargs, ...)

              char *name
              FVOID_STAR f
              SLtype type
              unsigned int nargs

      DDeessccrriippttiioonn
        The SLadd_intrinsic_function function may be used to add a new
        intrinsic function. The SS--LLaanngg name of the function is specified
        by name and the actual function pointer is given by f, cast to
        FVOID_STAR. The third parameter, type specifies the return type
        of the function and must be one of the following values:

              SLANG_VOID_TYPE   (returns nothing)
              SLANG_INT_TYPE    (returns int)
              SLANG_DOUBLE_TYPE (returns double)
              SLANG_STRING_TYPE (returns char *)

     The nargs parameter specifies the number of parameters to pass to
     the function. The variable argument list following nargs must con-
     sists of nargs integers which specify the data type of each argu-
     ment.

     The function returns zero upon success or -1 upon failure.

      EExxaammppllee
        The jjeedd editor uses this function to change the system intrinsic
        function to the following:

               static int jed_system (char *cmd)
               {
                  if (Jed_Secure_Mode)
                    {
                       msg_error ("Access denied.");
                       return -1;
                    }
                  return SLsystem (cmd);
               }

     After initializing the interpreter with SLang_init_slang, jjeedd calls
     SLadd_intrinsic_function to substitute the above definition for the
     default SS--LLaanngg definition:

               if (-1 == SLadd_intrinsic_function ("system", (FVOID_STAR)jed_system,
                                                   SLANG_INT_TYPE, 1,
                                                   SLANG_STRING_TYPE))
                 return -1;

      SSeeee AAllssoo
        SLadd_intrinsic_variable, SLadd_intrinsic_array

  55..4455..  SSLLaadddd__iinnttrriinnssiicc__vvaarriiaabbllee

      SSyynnooppssiiss
        Add an intrinsic variable to the interpreter

      UUssaaggee
        int SLadd_intrinsic_variable (name, addr, type, rdonly)

              char *name
              VOID_STAR addr
              SLtype type
              int rdonly

      DDeessccrriippttiioonn
        The SLadd_intrinsic_variable function adds an intrinsic variable
        called name to the interpeter. The second parameter addr
        specifies the address of the variable (cast to VOID_STAR). The
        third parameter, type, specifies the data type of the variable.
        If the fourth parameter, rdonly, is non-zero, the variable will
        interpreted by the interpreter as read-only.

        If successful, SLadd_intrinsic_variable returns zero, otherwise
        it returns -1.

      EExxaammppllee
        Suppose that My_Global_Int is a global variable (at least not a
        local one):

              int My_Global_Int;

     It can be added to the interpreter via the function call

              if (-1 == SLadd_intrinsic_variable ("MyGlobalInt",
                                                  (VOID_STAR)&My_Global_Int,
                                                  SLANG_INT_TYPE, 0))
                exit (1);

      NNootteess
        The current implementation requires all pointer type intrinsic
        variables to be read-only. For example,

              char *My_Global_String;

     is of type SLANG_STRING_TYPE, and must be declared as read-only.
     Finally, not that

             char My_Global_Char_Buf[256];

     is _n_o_t a SLANG_STRING_TYPE object. This difference is very impor-
     tant because internally the interpreter dereferences the address
     passed to it to get to the value of the variable.

      SSeeee AAllssoo
        SLadd_intrinsic_function, SLadd_intrinsic_array

  55..4466..  SSLLccllaassss__aadddd__uunnaarryy__oopp

      SSyynnooppssiiss
        ??

      UUssaaggee
        int SLclass_add_unary_op (SLtype,int (*) (int, SLtype,
        VOID_STAR, unsigned int, VOID_STAR), int (*) (int, SLtype,
        SLtype *));

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??
  55..4477..  SSLLccllaassss__aadddd__aapppp__uunnaarryy__oopp

      SSyynnooppssiiss
        ??

      UUssaaggee
        int SLclass_add_app_unary_op (SLtype, int (*) (int,SLtype,
        VOID_STAR, unsigned int,VOID_STAR),int (*) (int, SLtype, SLtype
        *));

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  55..4488..  SSLLccllaassss__aadddd__bbiinnaarryy__oopp

      SSyynnooppssiiss
        ??

      UUssaaggee
        int SLclass_add_binary_op (SLtype, SLtype,int (*)(int, SLtype,
        VOID_STAR, unsigned int,SLtype, VOID_STAR, unsigned
        int,VOID_STAR),int (*) (int, SLtype, SLtype, SLtype *));

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  55..4499..  SSLLccllaassss__aadddd__mmaatthh__oopp

      SSyynnooppssiiss
        ??

      UUssaaggee
        int SLclass_add_math_op (SLtype,int (*)(int,SLtype, VOID_STAR,
        unsigned int,VOID_STAR),int (*)(int, SLtype, SLtype *));

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  55..5500..  SSLLccllaassss__aadddd__ttyyppeeccaasstt

      SSyynnooppssiiss
        ??

      UUssaaggee
        int SLclass_add_typecast (SLtype, SLtype int (*)_PROTO((SLtype,
        VOID_STAR, unsigned int,SLtype, VOID_STAR)),int);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  66..  LLiibbrraarryy IInniittiiaalliizzaattiioonn FFuunnccttiioonnss

  66..11..  SSLLaanngg__iinniitt__ssllaanngg

      SSyynnooppssiiss
        Initialize the interpreter

      UUssaaggee
        int SLang_init_slang (void)

      DDeessccrriippttiioonn
        The SLang_init_slang function must be called by all applications
        that use the SS--LLaanngg interpreter. It initializes the interpreter,
        defines the built-in data types, and adds a set of core
        intrinsic functions.

        The function returns 0 upon success, or -1 upon failure.

      SSeeee AAllssoo
        SLang_init_slfile, SLang_init_slmath, SLang_init_slunix

  66..22..  SSLLaanngg__iinniitt__ssllffiillee

      SSyynnooppssiiss
        Initialize the interpreter file I/O intrinsics

      UUssaaggee
        int SLang_init_slfile (void)

      DDeessccrriippttiioonn
        This function initializes the interpreters file I/O intrinsic
        functions. This function adds intrinsic functions such as fopen,
        fclose, and fputs to the interpreter.  It returns 0 if
        successful, or -1 upon error.

      NNootteess
        Before this function can be called, it is first necessary to
        call SLang_init_slang. It also adds the preprocessor symbol
        __SLFILE__ to the interpreter.

      SSeeee AAllssoo
        SLang_init_slang, SLang_init_slunix, SLang_init_slmath

  66..33..  SSLLaanngg__iinniitt__ssllmmaatthh

      SSyynnooppssiiss
        Initialize the interpreter math intrinsics

      UUssaaggee
        int SLang_init_slmath (void)

      DDeessccrriippttiioonn
        The SLang_init_slmath function initializes the interpreter's
        mathematical intrinsic functions and makes them available to the
        language. The intrinsic functions include sin, cos, tan, etc...
        It returns 0 if successful, or -1 upon failure.

      NNootteess
        This function must be called after SLang_init_slang. It adds the
        preprocessor symbol __SLMATH__ to the interpreter.

      SSeeee AAllssoo
        SLang_init_slang, SLang_init_slfile, SLang_init_slunix

  66..44..  SSLLaanngg__iinniitt__sslluunniixx

      SSyynnooppssiiss
        Make available some unix system calls to the interpreter

      UUssaaggee
        int SLang_init_slunix (void)

      DDeessccrriippttiioonn
        The SLang_init_slunix function initializes the interpreter's
        unix system call intrinsic functions and makes them available to
        the language. Examples of functions made available by
        SLang_init_slunix include chmod, chown, and stat_file. It
        returns 0 if successful, or -1 upon failure.

      NNootteess
        This function must be called after SLang_init_slang. It adds the
        preprocessor symbol __SLUNIX__ to the interpreter.

      SSeeee AAllssoo
        SLang_init_slang, SLang_init_slfile, SLang_init_slmath

  77..  MMiisscceellllaanneeoouuss FFuunnccttiioonnss

  77..11..  SSLLccuurrrreenntt__ttiimmee__ssttrriinngg

      SSyynnooppssiiss
        Get the current time as a string

      UUssaaggee
        char *SLcurrent_time_string (void)

      DDeessccrriippttiioonn
        The SLcurrent_time_string function uses the C library function
        ctime to obtain a string representation of the current date and
        time in the form

          "Wed Dec 10 12:50:28 1997"

     However, unlike the ctime function, a newline character is not
     present in the string.

     The returned value points to a statically allocated memory block
     which may get overwritten on subsequent function calls.

      SSeeee AAllssoo
        SLmake_string

  77..22..  SSLLaattooii

      SSyynnooppssiiss
        Convert a text string to an integer

      UUssaaggee
        int SLatoi(unsigned char *str

      DDeessccrriippttiioonn
        SLatoi parses the string str to interpret it as an integer
        value. Unlike atoi, SLatoi can also parse strings containing
        integers expressed in hexidecimal (e.g., "0x7F") and octal
        (e.g., "012".)  notation.

      SSeeee AAllssoo
        SLang_guess_type

  77..33..  SSLLeexxttrraacctt__lliisstt__eelleemmeenntt

      SSyynnooppssiiss
        Extract a substring of a delimited string

      UUssaaggee
        int SLextract_list_element (dlist, nth, delim, buf, buflen)

              char *dlist;
              unsigned int nth;
              char delim;
              char *buf;
              unsigned int buflen;

      DDeessccrriippttiioonn
        SLextract_list_element may be used to obtain the nth element of
        a list of strings, dlist, that are delimited by the character
        delim. The routine copies the nth element of dlist to the buffer
        buf whose size is buflen characters. It returns zero upon
        success, or -1 if dlist does not contain an nth element.

      EExxaammppllee
        A delimited list of strings may be turned into an array of
        strings as follows. For conciseness, all malloc error checking
        has been omitted.

              int list_to_array (char *list, char delim, char ***ap)
              {
                 unsigned int nth;
                 char **a;
                 char buf[1024];

                 /* Determine the size of the array */
                 nth = 0;
                 while (0 == SLextract_list_element (list, nth, delim, buf, sizeof(buf)))
                   nth++;

                 ap = (char **) SLmalloc ((nth + 1) * sizeof (char **));
                 nth = 0;
                 while (0 == SLextract_list_element (list, nth, delim, buf, sizeof(buf)))
                   {
                       a[nth] = SLmake_string (buf);
                       nth++;
                   }
                 a[nth] = NULL;
                 *ap = a;
                 return 0;
              }

      SSeeee AAllssoo
        SLmalloc, SLmake_string

  88..  EErrrroorr aanndd MMeessssaaggiinngg FFuunnccttiioonnss

  88..11..  SSLLaanngg__vveerrrroorr

      SSyynnooppssiiss
        Signal an error with a message

      UUssaaggee
        void SLang_verror (int code, char *fmt, ...);

      DDeessccrriippttiioonn
        The SLang_verror function sets SLang_Error to code if
        SLang_Error is 0. It also displays the error message implied by
        the printf variable argument list using fmt as the format.

      EExxaammppllee

                FILE *open_file (char *file)
                {
                   char *file = "my_file.dat";
                   if (NULL == (fp = fopen (file, "w")))
                     SLang_verror (SL_INTRINSIC_ERROR, "Unable to open %s", file);
                   return fp;
                }

      SSeeee AAllssoo
        SLang_vmessage, SLang_exit_error

  88..22..  SSLLaanngg__ddooeerrrroorr

      SSyynnooppssiiss
        Signal an error

      UUssaaggee
        void SLang_doerror (char *err_str)

      DDeessccrriippttiioonn
        The SLang_doerror function displays the string err_str to the
        error device and signals a SS--LLaanngg error.

      NNootteess
        SLang_doerror is considered to obsolete. Applications should use
        the SLang_verror function instead.

      SSeeee AAllssoo
        SLang_verror, SLang_exit_error

  88..33..  SSLLaanngg__vvmmeessssaaggee

      SSyynnooppssiiss
        Display a message to the message device

      UUssaaggee
        void SLang_vmessage (char *fmt, ...)

      DDeessccrriippttiioonn
        This function prints a printf style formatted variable argument
        list to the message device. The default message device is
        stdout.

      SSeeee AAllssoo
        SLang_verror

  88..44..  SSLLaanngg__eexxiitt__eerrrroorr

      SSyynnooppssiiss
        Exit the program and display an error message

      UUssaaggee
        void SLang_exit_error (char *fmt, ...)

      DDeessccrriippttiioonn
        The SLang_exit_error function terminates the program and
        displays an error message using a printf type variable argument
        list. The default behavior to this function is to write the
        message to stderr and exit with the exit system call.

        If the function pointer SLang_Exit_Error_Hook is non-NULL, the
        function to which it points will be called. This permits an
        application to perform whatever cleanup is necessary.  This hook
        has the prototype:

               void (*SLang_Exit_Error_Hook)(char *, va_list);

      SSeeee AAllssoo
        SLang_verror, exit

  99..  SSttrriinngg aanndd MMeemmoorryy AAllllooccaattiioonn FFuunnccttiioonnss

  99..11..  SSLLmmaakkee__ssttrriinngg

      SSyynnooppssiiss
        Duplicate a string

      UUssaaggee
        char *SLmake_string (char *s)

      DDeessccrriippttiioonn
        The SLmake_string function creates a new copy of the string s,
        via malloc, and returns it. Upon failure it returns NULL. Since
        the resulting string is malloced, it should be freed when
        nolonger needed via a call to either free or SLfree.

      NNootteess
        SLmake_string should not be confused with the function
        SLang_create_slstring, which performs a similar function.

      SSeeee AAllssoo
        SLmake_nstring, SLfree, SLmalloc, SLang_create_slstring

  99..22..  SSLLmmaakkee__nnssttrriinngg

      SSyynnooppssiiss
        Duplicate a substring

      UUssaaggee
        char *SLmake_nstring (char *s, unsigned int n)

      DDeessccrriippttiioonn
        This function is like SLmake_string except that it creates a
        null terminated string formed from the first n characters of s.
        Upon failure, it returns NULL, otherwise it returns the new
        string. When nolonger needed, the returned string should be
        freed with SLfree.

      SSeeee AAllssoo
        SLmake_string, SLfree, SLang_create_nslstring

  99..33..  SSLLaanngg__ccrreeaattee__nnssllssttrriinngg

      SSyynnooppssiiss
        Created a hashed substring

      UUssaaggee
        char *SLang_create_nslstring (char *s, unsigned int n)

      DDeessccrriippttiioonn
        SLang_create_nslstring is like SLang_create_slstring except that
        only the first n characters of s are used to create the hashed
        string. Upon error, it returns NULL, otherwise it returns the
        hashed substring. Such a string must be freed by the function
        SLang_free_slstring.

      NNootteess
        Do not use free or SLfree to free the string returned by
        SLang_create_slstring or SLang_create_nslstring. Also it is
        important that no attempt is made to modify the hashed string
        returned by either of these functions. If one needs to modify a
        string, the functions SLmake_string or SLmake_nstring should be
        used instead.

      SSeeee AAllssoo
        SLang_free_slstring, SLang_create_slstring, SLmake_nstring

  99..44..  SSLLaanngg__ccrreeaattee__ssllssttrriinngg

      SSyynnooppssiiss
        Create a hashed string

      UUssaaggee
        char *SLang_create_slstring (char *s)

      DDeessccrriippttiioonn
        The SLang_create_slstring creates a copy of s and returns it as
        a hashed string. Upon error, the function returns NULL,
        otherwise it returns the hashed string. Such a string must only
        be freed via the SLang_free_slstring function.

      NNootteess
        Do not use free or SLfree to free the string returned by
        SLang_create_slstring or SLang_create_nslstring. Also it is
        important that no attempt is made to modify the hashed string
        returned by either of these functions. If one needs to modify a
        string, the functions SLmake_string or SLmake_nstring should be
        used instead.

      SSeeee AAllssoo
        SLang_free_slstring, SLang_create_nslstring, SLmake_string

  99..55..  SSLLaanngg__ffrreeee__ssllssttrriinngg

      SSyynnooppssiiss
        Free a hashed string

      UUssaaggee
        void SLang_free_slstring (char *s)
      DDeessccrriippttiioonn
        The SLang_free_slstring function is used to free a hashed string
        such as one returned by SLang_create_slstring,
        SLang_create_nslstring, or SLang_create_static_slstring.  If s
        is NULL, the routine does nothing.

      SSeeee AAllssoo
        SLang_create_slstring, SLang_create_nslstring,
        SLang_create_static_slstring

  99..66..  SSLLaanngg__ccoonnccaatt__ssllssttrriinnggss

      SSyynnooppssiiss
        Concatenate two strings to produce a hashed string

      UUssaaggee
        char *SLang_concat_slstrings (char *a, char *b)

      DDeessccrriippttiioonn
        The SLang_concat_slstrings function concatenates two strings, a
        and b, and returns the result as a hashed string.  Upon failure,
        NULL is returned.

      NNootteess
        A hashed string can only be freed using SLang_free_slstring.
        Never use free or SLfree to free a hashed string, otherwise
        memory corruption will result.

      SSeeee AAllssoo
        SLang_free_slstring, SLang_create_slstring

  99..77..  SSLLaanngg__ccrreeaattee__ssttaattiicc__ssllssttrriinngg

      SSyynnooppssiiss
        Create a hashed string

      UUssaaggee
        char *SLang_create_static_slstring (char *s_literal)

      DDeessccrriippttiioonn
        The SLang_create_static_slstring creates a hashed string from
        the string literal s_literal and returns the result. Upon
        failure it returns NULL.

      EExxaammppllee

               char *create_hello (void)
               {
                  return SLang_create_static_slstring ("hello");
               }

      NNootteess
        This function should only be used with string literals.

      SSeeee AAllssoo
        SLang_create_slstring, SLang_create_nslstring

  99..88..  SSLLmmaalllloocc

      SSyynnooppssiiss
        Allocate some memory

      UUssaaggee
        char *SLmalloc (unsigned int nbytes)

      DDeessccrriippttiioonn
        This function uses malloc to allocate nbytes of memory.  Upon
        error it returns NULL; otherwise it returns a pointer to the
        allocated memory. One should use SLfree to free the memory after
        use.

      SSeeee AAllssoo
        SLfree, SLrealloc, SLcalloc

  99..99..  SSLLccaalllloocc

      SSyynnooppssiiss
        Allocate some memory

      UUssaaggee
        char *SLcalloc (unsigned int num_elem, unsigned int elem_size)

      DDeessccrriippttiioonn
        This function uses calloc to allocate memory for num_elem
        objects with each of size elem_size and returns the result. In
        addition, the newly allocated memory is zeroed.  Upon error it
        returns NULL; otherwise it returns a pointer to the allocated
        memory. One should use SLfree to free the memory after use.

      SSeeee AAllssoo
        SLmalloc, SLrealloc, SLfree

  99..1100..  SSLLffrreeee

      SSyynnooppssiiss
        Free some allocated memory

      UUssaaggee
        void SLfree (char *ptr)

      DDeessccrriippttiioonn
        The SLfree function deallocates the memory specified by ptr,
        which may be NULL in which case the function does nothing.

      NNootteess
        Never use this function to free a hashed string returned by one
        of the family of slstring functions, e.g., SLang_pop_slstring.

      SSeeee AAllssoo
        SLmalloc, SLcalloc, SLrealloc, SLmake_string

  99..1111..  SSLLrreeaalllloocc

      SSyynnooppssiiss
        Resize a dynamic memory block

      UUssaaggee
        char *SLrealloc (char *ptr, unsigned int new_size)

      DDeessccrriippttiioonn
        The SLrealloc uses the realloc function to resize the memory
        block specified by ptr to the new size new_size.  If ptr is
        NULL, the function call is equivalent to SLmalloc(new_size).
        Similarly, if new_size is zero, the function call is equivalent
        to SLfree(ptr).

        If the function fails, or if new_size is zero, NULL is returned.
        Otherwise a pointer is returned to the (possibly moved) new
        block of memory.

      SSeeee AAllssoo
        SLfree, SLmalloc, SLcalloc

  1100..  KKeeyybbooaarrdd IInnppuutt FFuunnccttiioonnss

  1100..11..  SSLLaanngg__iinniitt__ttttyy

      SSyynnooppssiiss
        Initialize the terminal keyboard interface

      UUssaaggee
        int SLang_init_tty (int intr_ch, int no_flow_ctrl, int opost)

      DDeessccrriippttiioonn
        SLang_init_tty initializes the terminal for single character
        input. If the first parameter intr_ch is in the range 0-255, it
        will be used as the interrupt character, e.g., under Unix this
        character will generate a SIGINT signal. Otherwise, if it is -1,
        the interrupt character will be left unchanged.

        If the second parameter no_flow_ctrl is non-zero, flow control
        (XON/XOFF) processing will be enabled.

        If the last parmeter opost is non-zero, output processing by the
        terminal will be enabled. If one intends to use this function in
        conjunction with the SS--LLaanngg screen management routines (SLsmg),
        this paramete shold be set to zero.

        SLang_init_tty returns zero upon success, or -1 upon error.

      NNootteess
        Terminal I/O is a complex subject. The SS--LLaanngg interface presents
        a simplification that the author has found useful in practice.
        For example, the only special character processing that
        SLang_init_tty enables is that of the SIGINT character, and the
        generation of other signals via the keyboard is disabled.
        However, generation of the job control signal SIGTSTP is
        possible via the SLtty_set_suspend_state function.

        Under Unix, the integer variable SLang_TT_Read_FD is used to
        specify the input descriptor for the terminal. If
        SLang_TT_Read_FD represents a terminal device as determined via
        the isatty system call, then it will be used as the terminal
        file descriptor. Otherwise, the terminal device /dev/tty will
        used as the input device. The default value of SLang_TT_Read_FD
        is -1 which causes /dev/tty to be used. So, if you prefer to use
        stdin for input, then set SLang_TT_Read_FD to fileno(stdin)
        _b_e_f_o_r_e calling SLang_init_tty.

        If the variable SLang_TT_Baud_Rate is zero when this function is
        called, the function will attempt to determine the baud rate by
        querying the terminal driver and set SLang_TT_Baud_Rate to that
        value.

      SSeeee AAllssoo
        SLang_reset_tty, SLang_getkey, SLtty_set_suspend_state

  1100..22..  SSLLaanngg__rreesseett__ttttyy

      SSyynnooppssiiss
        Reset the terminal

      UUssaaggee
        void SLang_reset_tty (void)

      DDeessccrriippttiioonn
        SLang_reset_tty resets the terminal interface back to the state
        it was in before SLang_init_tty was called.

      SSeeee AAllssoo
        SLang_init_tty

  1100..33..  SSLLttttyy__sseett__ssuussppeenndd__ssttaattee

      SSyynnooppssiiss
        Enable or disable keyboard suspension

      UUssaaggee
        void SLtty_set_suspend_state (int s)

      DDeessccrriippttiioonn
        The SLtty_set_suspend_state function may be used to enable or
        disable keyboard generation of the SIGTSTP job control signal.
        If s is non-zero, generation of this signal via the terminal
        interface will be enabled, otherwise it will be disabled.

        This function should only be called after the terminal driver
        has be initialized via SLang_init_tty. The SLang_init_tty always
        disables the generation of SIGTSTP via the keyboard.

      SSeeee AAllssoo
        SLang_init_tty
  1100..44..  SSLLaanngg__ggeettkkeeyy

      SSyynnooppssiiss
        Read a character from the keyboard

      UUssaaggee
        unsigned int SLang_getkey (void);

      DDeessccrriippttiioonn
        The SLang_getkey reads a single character from the terminal and
        returns it. The terminal must first be initialized via a call to
        SLang_init_tty before this function can be called. Upon success,
        SLang_getkey returns the character read from the terminal,
        otherwise it returns SLANG_GETKEY_ERROR.

      SSeeee AAllssoo
        SLang_init_tty, SLang_input_pending, SLang_ungetkey

  1100..55..  SSLLaanngg__uunnggeettkkeeyy__ssttrriinngg

      SSyynnooppssiiss
        Unget a key string

      UUssaaggee
        int SLang_ungetkey_string (unsigned char *buf, unsigned int n)

      DDeessccrriippttiioonn
        The SLang_ungetkey_string function may be used to push the n
        characters pointed to by buf onto the buffered input stream that
        SLgetkey uses. If there is not enough room for the characters,
        -1 is returned and none are buffered. Otherwise, it returns
        zero.

      NNootteess
        The difference between SLang_buffer_keystring and
        SLang_ungetkey_string is that the SLang_buffer_keystring appends
        the characters to the end of the getkey buffer, whereas
        SLang_ungetkey_string inserts the characters at the beginning of
        the input buffer.

      SSeeee AAllssoo
        SLang_ungetkey, SLang_getkey

  1100..66..  SSLLaanngg__bbuuffffeerr__kkeeyyssttrriinngg

      SSyynnooppssiiss
        Append a keystring to the input buffer

      UUssaaggee
        int SLang_buffer_keystring (unsigned char *b, unsigned int len)

      DDeessccrriippttiioonn
        SLang_buffer_keystring places the len characters specified by b
        at the _e_n_d of the buffer that SLang_getkey uses. Upon success it
        returns 0; otherwise, no characters are buffered and it returns
        -1.

      NNootteess
        The difference between SLang_buffer_keystring and
        SLang_ungetkey_string is that the SLang_buffer_keystring appends
        the characters to the end of the getkey buffer, whereas
        SLang_ungetkey_string inserts the characters at the beginning of
        the input buffer.

      SSeeee AAllssoo
        SLang_getkey, SLang_ungetkey, SLang_ungetkey_string

  1100..77..  SSLLaanngg__uunnggeettkkeeyy

      SSyynnooppssiiss
        Push a character back onto the input buffer

      UUssaaggee
        int SLang_ungetkey (unsigned char ch)

      DDeessccrriippttiioonn
        SLang_ungetkey pushes the character ch back onto the SLgetkey
        input stream. Upon success, it returns zero, otherwise it
        returns 1.

      EExxaammppllee
        This function is implemented as:

              int SLang_ungetkey (unsigned char ch)
              {
                 return SLang_ungetkey_string(&ch, 1);
              }

      SSeeee AAllssoo
        SLang_getkey, SLang_ungetkey_string

  1100..88..  SSLLaanngg__fflluusshh__iinnppuutt

      SSyynnooppssiiss
        Discard all keyboard input waiting to be read

      UUssaaggee
        void SLang_flush_input (void)

      DDeessccrriippttiioonn
        SLang_flush_input discards all input characters waiting to be
        read by the SLang_getkey function.

      SSeeee AAllssoo
        SLang_getkey

  1100..99..  SSLLaanngg__iinnppuutt__ppeennddiinngg

      SSyynnooppssiiss
        Check to see if input is pending

      UUssaaggee
        int SLang_input_pending (int tsecs)

      DDeessccrriippttiioonn
        SLang_input_pending may be used to see if an input character is
        available to be read without causing SLang_getkey to block.  It
        will wait up to tsecs tenths of a second if no characters are
        immediately available for reading. If tsecs is less than zero,
        then SLang_input_pending will wait -tsecs milliseconds for
        input, otherwise tsecs represents 1/10 of a second intervals.

      NNootteess
        Not all systems support millisecond resolution.

      SSeeee AAllssoo
        SLang_getkey

  1100..1100..  SSLLaanngg__sseett__aabboorrtt__ssiiggnnaall

      SSyynnooppssiiss
        Set the signal to trap SIGINT

      UUssaaggee
        void SLang_set_abort_signal (void (*f)(int));

      DDeessccrriippttiioonn
        SLang_set_abort_signal sets the function that gets triggered
        when the user presses the interrupt key (SIGINT) to the function
        f. If f is NULL the default handler will get installed.

      EExxaammppllee
        The default interrupt handler on a Unix system is:

               static void default_sigint (int sig)
               {
                  SLKeyBoard_Quit = 1;
                  if (SLang_Ignore_User_Abort == 0) SLang_Error = SL_USER_BREAK;
                  SLsignal_intr (SIGINT, default_sigint);
             }

      NNootteess
        For Unix programmers, the name of this function may appear
        misleading since it is associated with SIGINT and not SIGABRT.
        The origin of the name stems from the original intent of the
        function: to allow the user to abort the running of a SS--LLaanngg
        interpreter function.

      SSeeee AAllssoo
        SLang_init_tty, SLsignal_intr

  1111..  KKeeyymmaapp FFuunnccttiioonnss

  1111..11..  SSLLkkmm__ddeeffiinnee__kkeeyy

      SSyynnooppssiiss
        Define a key in a keymap

      UUssaaggee
        int SLkm_define_key (char *seq, FVOID_STAR f, SLKeyMap_List_Type
        *km)

      DDeessccrriippttiioonn
        SLkm_define_key associates the key sequence seq with the
        function pointer f in the keymap specified by km. Upon success,
        it returns zero, otherwise it returns a negative integer upon
        error.

      SSeeee AAllssoo
        SLkm_define_keysym, SLang_define_key

  1111..22..  SSLLaanngg__ddeeffiinnee__kkeeyy

      SSyynnooppssiiss
        Define a key in a keymap

      UUssaaggee
        int SLang_define_key(char *seq, char *fun, SLKeyMap_List_Type
        *km)

      DDeessccrriippttiioonn
        SLang_define_key associates the key sequence seq with the
        function whose name is fun in the keymap specified by km.

      SSeeee AAllssoo
        SLkm_define_keysym, SLkm_define_key

  1111..33..  SSLLkkmm__ddeeffiinnee__kkeeyyssyymm

      SSyynnooppssiiss
        Define a keysym in a keymap

      UUssaaggee
        int SLkm_define_keysym (seq, ks, km)

                char *seq;
                unsigned int ks;
                SLKeyMap_List_Type *km;

      DDeessccrriippttiioonn
        SLkm_define_keysym associates the key sequence seq with the
        keysym ks in the keymap km. Keysyms whose value is less than or
        equal to 0x1000 is reserved by the library and should not be
        used.

      SSeeee AAllssoo
        SLkm_define_key, SLang_define_key

  1111..44..  SSLLaanngg__uunnddeeffiinnee__kkeeyy

      SSyynnooppssiiss
        Undefined a key from a keymap

      UUssaaggee
        void SLang_undefine_key(char *seq, SLKeyMap_List_Type *km);

      DDeessccrriippttiioonn
        SLang_undefine_key removes the key sequence seq from the keymap
        km.

      SSeeee AAllssoo
        SLang_define_key

  1111..55..  SSLLaanngg__ccrreeaattee__kkeeyymmaapp

      SSyynnooppssiiss
        Create a new keymap

      UUssaaggee
        SLKeyMap_List_Type *SLang_create_keymap (name, km)

               char *name;
               SLKeyMap_List_Type *km;

      DDeessccrriippttiioonn
        SLang_create_keymap creates a new keymap called name by copying
        the key definitions from the keymap km. If km is NULL, the newly
        created keymap will be empty and it is up to the calling routine
        to initialize it via the SLang_define_key and SLkm_define_keysym
        functions.  SLang_create_keymap returns a pointer to the new
        keymap, or NULL upon failure.

      SSeeee AAllssoo
        SLang_define_key, SLkm_define_keysym

  1111..66..  SSLLaanngg__ddoo__kkeeyy

      SSyynnooppssiiss
        Read a keysequence and return its keymap entry

      UUssaaggee
        SLang_Key_Type *SLang_do_key (kml, getkey)

          SLKeyMap_List_Type *kml;
          int (*getkey)(void);

      DDeessccrriippttiioonn
        The SLang_do_key function reads characters using the function
        specified by the getkey function pointer and uses the key
        sequence to return the appropriate entry in the keymap specified
        by kml.

        SLang_do_key returns NULL if the key sequence is not defined by
        the keymap, otherwise it returns a pointer to an object of type
        SLang_Key_Type, which is defined in slang.h as

               #define SLANG_MAX_KEYMAP_KEY_SEQ 14
               typedef struct SLang_Key_Type
               {
                 struct SLang_Key_Type *next;
                 union
                 {
                    char *s;
                    FVOID_STAR f;
                    unsigned int keysym;
                 }
                 f;
                 unsigned char type;             /* type of function */
               #define SLKEY_F_INTERPRET  0x01
               #define SLKEY_F_INTRINSIC  0x02
               #define SLKEY_F_KEYSYM     0x03
                 unsigned char str[SLANG_MAX_KEYMAP_KEY_SEQ + 1];/* key sequence */
               }
          SLang_Key_Type;

     The type field specifies which field of the union f should be used.
     If type is SLKEY_F_INTERPRET, then f.s is a string that should be
     passed to the interpreter for evaluation. If type is
     SLKEY_F_INTRINSIC, then f.f refers to function that should be
     called. Otherwise, type is SLKEY_F_KEYSYM and f.keysym represents
     the value of the keysym that is associated with the key sequence.

      SSeeee AAllssoo
        SLkm_define_keysym, SLkm_define_key

  1111..77..  SSLLaanngg__ffiinndd__kkeeyy__ffuunnccttiioonn

      SSyynnooppssiiss
        Obtain a function pointer associated with a keymap

      UUssaaggee
        FVOID_STAR SLang_find_key_function (fname, km);

              char *fname;
              SLKeyMap_List_Type *km;

      DDeessccrriippttiioonn
        The SLang_find_key_function routine searches through the
        SLKeymap_Function_Type list of functions associated with the
        keymap km for the function with name fname.  If a matching
        function is found, a pointer to the function will be returned,
        otherwise SLang_find_key_function will return NULL.

      SSeeee AAllssoo
        SLang_create_keymap, SLang_find_keymap

  1111..88..  SSLLaanngg__ffiinndd__kkeeyymmaapp

      SSyynnooppssiiss
        Find a keymap

      UUssaaggee
        SLKeyMap_List_Type *SLang_find_keymap (char *keymap_name);

      DDeessccrriippttiioonn
        The SLang_find_keymap function searches through the list of
        keymaps looking for one whose name is keymap_name. If a matching
        keymap is found, the function returns a pointer to the keymap.
        It returns NULL if no such keymap exists.

      SSeeee AAllssoo
        SLang_create_keymap, SLang_find_key_function

  1111..99..  SSLLaanngg__pprroocceessss__kkeeyyssttrriinngg

      SSyynnooppssiiss
        Un-escape a key-sequence

      UUssaaggee
        char *SLang_process_keystring (char *kseq);

      DDeessccrriippttiioonn
        The SLang_process_keystring function converts an escaped key
        sequence to its raw form by converting two-character
        combinations such as ^A to the _s_i_n_g_l_e character Ctrl-A (ASCII
        1). In addition, if the key sequence contains constructs such as
        ^(XX), where XX represents a two-character termcap specifier,
        the termcap escape sequence will be looked up and substituted.

        Upon success, SLang_process_keystring returns a raw key-sequence
        whose first character represents the total length of the key-
        sequence, including the length specifier itself. It returns NULL
        upon failure.

      EExxaammppllee
        Consider the following examples:

               SLang_process_keystring ("^X^C");
               SLang_process_keystring ("^[[A");

     The first example will return a pointer to a buffer of three
     characters whose ASCII values are given by {3,24,3}. Similarly, the
     second example will return a pointer to the four characters
     {4,27,91,65}. Finally, the result of

               SLang_process_keystring ("^[^(ku)");

     will depend upon the termcap/terminfo capability "ku", which repre-
     sents the escape sequence associated with the terminal's UP arrow
     key. For an ANSI terminal whose UP arrow produces "ESC [ A", the
     result will be 5,27,27,91,65.

      NNootteess
        SLang_process_keystring returns a pointer to a static area that
        will be overwritten on subsequent calls.

      SSeeee AAllssoo
        SLang_define_key, SLang_make_keystring

  1111..1100..  SSLLaanngg__mmaakkee__kkeeyyssttrriinngg

      SSyynnooppssiiss
        Make a printable key sequence

      UUssaaggee
        char *SLang_make_keystring (unsigned char *ks);

      DDeessccrriippttiioonn
        The SLang_make_keystring function takes a raw key sequence ks
        and converts it to a printable form by converting characters
        such as ASCII 1 (ctrl-A) to ^A. That is, it performs the
        opposite function of SLang_process_keystring.

      NNootteess
        This function returns a pointer to a static area that will be
        overwritten on the next call to SLang_make_keystring.

      SSeeee AAllssoo
        SLang_process_keystring

  1122..  UUnnddooccuummeenntteedd FFuunnccttiioonnss

  The following functions are not yet documented:

  1122..11..  SSLLpprreepp__ooppeenn__pprreepp

      SSyynnooppssiiss
        ??

      UUssaaggee
        int SLprep_open_prep (SLPreprocess_Type *);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..22..  SSLLpprreepp__cclloossee__pprreepp

      SSyynnooppssiiss
        ??

      UUssaaggee
        void SLprep_close_prep (SLPreprocess_Type *);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..33..  SSLLpprreepp__lliinnee__ookk

      SSyynnooppssiiss
        ??

      UUssaaggee
        int SLprep_line_ok (char *, SLPreprocess_Type *);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..44..  SSLLddeeffiinnee__ffoorr__iiffddeeff

      SSyynnooppssiiss
        ??

      UUssaaggee
        int SLdefine_for_ifdef (char *);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..55..  SSLLaanngg__RReeaadd__LLiinnee__TTyyppee ** SSLLaanngg__rrlliinnee__ssaavvee__lliinnee
  ((SSLLaanngg__RRLLiinnee__IInnffoo__TTyyppee **));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        SLang_Read_Line_Type * SLang_rline_save_line
        (SLang_RLine_Info_Type *);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..66..  iinntt SSLLaanngg__iinniitt__rreeaaddlliinnee ((SSLLaanngg__RRLLiinnee__IInnffoo__TTyyppee **));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        int SLang_init_readline (SLang_RLine_Info_Type *);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..77..  iinntt SSLLaanngg__rreeaadd__lliinnee ((SSLLaanngg__RRLLiinnee__IInnffoo__TTyyppee **));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        int SLang_read_line (SLang_RLine_Info_Type *);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..88..  iinntt SSLLaanngg__rrlliinnee__iinnsseerrtt ((cchhaarr **));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        int SLang_rline_insert (char *);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..99..  vvooiidd SSLLrrlliinnee__rreeddrraaww ((SSLLaanngg__RRLLiinnee__IInnffoo__TTyyppee **));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        void SLrline_redraw (SLang_RLine_Info_Type *);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..1100..  iinntt SSLLtttt__fflluusshh__oouuttppuutt ((vvooiidd));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        int SLtt_flush_output (void);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..1111..  vvooiidd SSLLtttt__sseett__ssccrroollll__rreeggiioonn((iinntt,, iinntt));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        void SLtt_set_scroll_region(int, int);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..1122..  vvooiidd SSLLtttt__rreesseett__ssccrroollll__rreeggiioonn((vvooiidd));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        void SLtt_reset_scroll_region(void);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..1133..  vvooiidd SSLLtttt__rreevveerrssee__vviiddeeoo ((iinntt));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        void SLtt_reverse_video (int);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..1144..  vvooiidd SSLLtttt__bboolldd__vviiddeeoo ((vvooiidd));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        void SLtt_bold_video (void);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..1155..  vvooiidd SSLLtttt__bbeeggiinn__iinnsseerrtt((vvooiidd));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        void SLtt_begin_insert(void);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..1166..  vvooiidd SSLLtttt__eenndd__iinnsseerrtt((vvooiidd));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        void SLtt_end_insert(void);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..1177..  vvooiidd SSLLtttt__ddeell__eeooll((vvooiidd));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        void SLtt_del_eol(void);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..1188..  vvooiidd SSLLtttt__ggoottoo__rrcc ((iinntt,, iinntt));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        void SLtt_goto_rc (int, int);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..1199..  vvooiidd SSLLtttt__ddeelleettee__nnlliinneess((iinntt));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        void SLtt_delete_nlines(int);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..2200..  vvooiidd SSLLtttt__ddeelleettee__cchhaarr((vvooiidd));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        void SLtt_delete_char(void);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..2211..  vvooiidd SSLLtttt__eerraassee__lliinnee((vvooiidd));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        void SLtt_erase_line(void);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..2222..  vvooiidd SSLLtttt__nnoorrmmaall__vviiddeeoo((vvooiidd));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        void SLtt_normal_video(void);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..2233..  vvooiidd SSLLtttt__ccllss((vvooiidd));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        void SLtt_cls(void);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..2244..  vvooiidd SSLLtttt__bbeeeepp((vvooiidd));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        void SLtt_beep(void);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..2255..  vvooiidd SSLLtttt__rreevveerrssee__iinnddeexx((iinntt));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        void SLtt_reverse_index(int);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..2266..  vvooiidd SSLLtttt__ssmmaarrtt__ppuuttss((uunnssiiggnneedd sshhoorrtt **,, uunnssiiggnneedd sshhoorrtt **,, iinntt,,
  iinntt));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        void SLtt_smart_puts(unsigned short *, unsigned short *, int,
        int);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..2277..  vvooiidd SSLLtttt__wwrriittee__ssttrriinngg ((cchhaarr **));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        void SLtt_write_string (char *);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..2288..  vvooiidd SSLLtttt__ppuuttcchhaarr((cchhaarr));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        void SLtt_putchar(char);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..2299..  iinntt SSLLtttt__iinniitt__vviiddeeoo ((vvooiidd));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        int SLtt_init_video (void);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..3300..  iinntt SSLLtttt__rreesseett__vviiddeeoo ((vvooiidd));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        int SLtt_reset_video (void);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..3311..  vvooiidd SSLLtttt__ggeett__tteerrmmiinnffoo((vvooiidd));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        void SLtt_get_terminfo(void);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..3322..  vvooiidd SSLLtttt__ggeett__ssccrreeeenn__ssiizzee ((vvooiidd));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        void SLtt_get_screen_size (void);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..3333..  iinntt SSLLtttt__sseett__ccuurrssoorr__vviissiibbiilliittyy ((iinntt));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        int SLtt_set_cursor_visibility (int);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..3344..  iinntt SSLLtttt__iinniittiiaalliizzee ((cchhaarr **));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        int SLtt_initialize (char *);

      DDeessccrriippttiioonn
        ??
      SSeeee AAllssoo
        ??

  1122..3355..  vvooiidd SSLLtttt__eennaabbllee__ccuurrssoorr__kkeeyyss((vvooiidd));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        void SLtt_enable_cursor_keys(void);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..3366..  vvooiidd SSLLtttt__sseett__tteerrmm__vvttxxxxxx((iinntt **));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        void SLtt_set_term_vtxxx(int *);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..3377..  vvooiidd SSLLtttt__sseett__ccoolloorr__eesscc ((iinntt,, cchhaarr **));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        void SLtt_set_color_esc (int, char *);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..3388..  vvooiidd SSLLtttt__wwiiddee__wwiiddtthh((vvooiidd));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        void SLtt_wide_width(void);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..3399..  vvooiidd SSLLtttt__nnaarrrrooww__wwiiddtthh((vvooiidd));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        void SLtt_narrow_width(void);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..4400..  iinntt SSLLtttt__sseett__mmoouussee__mmooddee ((iinntt,, iinntt));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        int SLtt_set_mouse_mode (int, int);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..4411..  vvooiidd SSLLtttt__sseett__aalltt__cchhaarr__sseett ((iinntt));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        void SLtt_set_alt_char_set (int);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..4422..  iinntt SSLLtttt__wwrriittee__ttoo__ssttaattuuss__lliinnee ((cchhaarr **,, iinntt));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        int SLtt_write_to_status_line (char *, int);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..4433..  vvooiidd SSLLtttt__ddiissaabbllee__ssttaattuuss__lliinnee ((vvooiidd));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        void SLtt_disable_status_line (void);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..4444..  cchhaarr **SSLLtttt__ttggeettssttrr ((cchhaarr **));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        char *SLtt_tgetstr (char *);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..4455..  iinntt SSLLtttt__ttggeettnnuumm ((cchhaarr **));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        int SLtt_tgetnum (char *);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..4466..  iinntt SSLLtttt__ttggeettffllaagg ((cchhaarr **));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        int SLtt_tgetflag (char *);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..4477..  cchhaarr **SSLLtttt__ttiiggeetteenntt ((cchhaarr **));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        char *SLtt_tigetent (char *);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..4488..  cchhaarr **SSLLtttt__ttiiggeettssttrr ((cchhaarr **,, cchhaarr ****));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        char *SLtt_tigetstr (char *, char **);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..4499..  iinntt SSLLtttt__ttiiggeettnnuumm ((cchhaarr **,, cchhaarr ****));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        int SLtt_tigetnum (char *, char **);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..5500..  SSLLtttt__CChhaarr__TTyyppee SSLLtttt__ggeett__ccoolloorr__oobbjjeecctt ((iinntt));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        SLtt_Char_Type SLtt_get_color_object (int);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..5511..  vvooiidd SSLLtttt__sseett__ccoolloorr__oobbjjeecctt ((iinntt,, SSLLtttt__CChhaarr__TTyyppee));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        void SLtt_set_color_object (int, SLtt_Char_Type);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..5522..  vvooiidd SSLLtttt__sseett__ccoolloorr ((iinntt,, cchhaarr **,, cchhaarr **,, cchhaarr **));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        void SLtt_set_color (int, char *, char *, char *);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..5533..  vvooiidd SSLLtttt__sseett__mmoonnoo ((iinntt,, cchhaarr **,, SSLLtttt__CChhaarr__TTyyppee));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        void SLtt_set_mono (int, char *, SLtt_Char_Type);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..5544..  vvooiidd SSLLtttt__aadddd__ccoolloorr__aattttrriibbuuttee ((iinntt,, SSLLtttt__CChhaarr__TTyyppee));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        void SLtt_add_color_attribute (int, SLtt_Char_Type);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..5555..  vvooiidd SSLLtttt__sseett__ccoolloorr__ffggbbgg ((iinntt,, SSLLtttt__CChhaarr__TTyyppee,,
  SSLLtttt__CChhaarr__TTyyppee));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        void SLtt_set_color_fgbg (int, SLtt_Char_Type, SLtt_Char_Type);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..5566..  iinntt SSLLkkpp__ddeeffiinnee__kkeeyyssyymm ((cchhaarr **,, uunnssiiggnneedd iinntt));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        int SLkp_define_keysym (char *, unsigned int);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..5577..  iinntt SSLLkkpp__iinniitt ((vvooiidd));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        int SLkp_init (void);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..5588..  iinntt SSLLkkpp__ggeettkkeeyy ((vvooiidd));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        int SLkp_getkey (void);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..5599..  iinntt SSLLssccrroollll__ffiinndd__ttoopp ((SSLLssccrroollll__WWiinnddooww__TTyyppee **));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        int SLscroll_find_top (SLscroll_Window_Type *);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..6600..  iinntt SSLLssccrroollll__ffiinndd__lliinnee__nnuumm ((SSLLssccrroollll__WWiinnddooww__TTyyppee **));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        int SLscroll_find_line_num (SLscroll_Window_Type *);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..6611..  uunnssiiggnneedd iinntt SSLLssccrroollll__nneexxtt__nn ((SSLLssccrroollll__WWiinnddooww__TTyyppee **,, uunnssiiggnneedd
  iinntt));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        unsigned int SLscroll_next_n (SLscroll_Window_Type *, unsigned
        int);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..6622..  uunnssiiggnneedd iinntt SSLLssccrroollll__pprreevv__nn ((SSLLssccrroollll__WWiinnddooww__TTyyppee **,, uunnssiiggnneedd
  iinntt));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        unsigned int SLscroll_prev_n (SLscroll_Window_Type *, unsigned
        int);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..6633..  iinntt SSLLssccrroollll__ppaaggeeuupp ((SSLLssccrroollll__WWiinnddooww__TTyyppee **));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        int SLscroll_pageup (SLscroll_Window_Type *);
      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..6644..  iinntt SSLLssccrroollll__ppaaggeeddoowwnn ((SSLLssccrroollll__WWiinnddooww__TTyyppee **));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        int SLscroll_pagedown (SLscroll_Window_Type *);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..6655..  SSLLSSiigg__FFuunn__TTyyppee **SSLLssiiggnnaall ((iinntt,, SSLLSSiigg__FFuunn__TTyyppee **));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        SLSig_Fun_Type *SLsignal (int, SLSig_Fun_Type *);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..6666..  SSLLSSiigg__FFuunn__TTyyppee **SSLLssiiggnnaall__iinnttrr ((iinntt,, SSLLSSiigg__FFuunn__TTyyppee **));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        SLSig_Fun_Type *SLsignal_intr (int, SLSig_Fun_Type *);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..6677..  iinntt SSLLssiigg__bblloocckk__ssiiggnnaallss ((vvooiidd));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        int SLsig_block_signals (void);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..6688..  iinntt SSLLssiigg__uunnbblloocckk__ssiiggnnaallss ((vvooiidd));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        int SLsig_unblock_signals (void);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..6699..  iinntt SSLLssyysstteemm ((cchhaarr **));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        int SLsystem (char *);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..7700..  vvooiidd SSLLaadddd__aatt__hhaannddlleerr ((lloonngg **,, cchhaarr **));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        void SLadd_at_handler (long *, char *);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..7711..  vvooiidd SSLLaanngg__ddeeffiinnee__ccaassee((iinntt **,, iinntt **));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        void SLang_define_case(int *, int *);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..7722..  vvooiidd SSLLaanngg__iinniitt__ccaassee__ttaabblleess ((vvooiidd));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        void SLang_init_case_tables (void);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..7733..  uunnssiiggnneedd cchhaarr **SSLLaanngg__rreeggeexxpp__mmaattcchh((uunnssiiggnneedd cchhaarr **,, uunnssiiggnneedd
  iinntt,, SSLLRReeggeexxpp__TTyyppee **));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        unsigned char *SLang_regexp_match(unsigned char *, unsigned int,
        SLRegexp_Type *);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..7744..  iinntt SSLLaanngg__rreeggeexxpp__ccoommppiillee ((SSLLRReeggeexxpp__TTyyppee **));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        int SLang_regexp_compile (SLRegexp_Type *);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..7755..  cchhaarr **SSLLrreeggeexxpp__qquuoottee__ssttrriinngg ((cchhaarr **,, cchhaarr **,, uunnssiiggnneedd iinntt));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        char *SLregexp_quote_string (char *, char *, unsigned int);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..7766..  iinntt SSLLccmmdd__eexxeeccuuttee__ssttrriinngg ((cchhaarr **,, SSLLccmmdd__CCmmdd__TTaabbllee__TTyyppee **));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        int SLcmd_execute_string (char *, SLcmd_Cmd_Table_Type *);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..7777..  SSLLccoommpplleexx__aabbss

      SSyynnooppssiiss
        Returns the norm of a complex number

      UUssaaggee
        double SLcomplex_abs (double *z)}

      DDeessccrriippttiioonn
        The SLcomplex_abs function returns the absolute value or the
        norm of the complex number given by z.
      SSeeee AAllssoo
        SLcomplex_times

  1122..7788..  ddoouubbllee **SSLLccoommpplleexx__ttiimmeess ((ddoouubbllee **,, ddoouubbllee **,, ddoouubbllee **));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        double *SLcomplex_times (double *, double *, double *);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..7799..  ddoouubbllee **SSLLccoommpplleexx__ddiivviiddee ((ddoouubbllee **,, ddoouubbllee **,, ddoouubbllee **));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        double *SLcomplex_divide (double *, double *, double *);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..8800..  ddoouubbllee **SSLLccoommpplleexx__ssiinn ((ddoouubbllee **,, ddoouubbllee **));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        double *SLcomplex_sin (double *, double *);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..8811..  ddoouubbllee **SSLLccoommpplleexx__ccooss ((ddoouubbllee **,, ddoouubbllee **));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        double *SLcomplex_cos (double *, double *);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..8822..  ddoouubbllee **SSLLccoommpplleexx__ttaann ((ddoouubbllee **,, ddoouubbllee **));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        double *SLcomplex_tan (double *, double *);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..8833..  ddoouubbllee **SSLLccoommpplleexx__aassiinn ((ddoouubbllee **,, ddoouubbllee **));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        double *SLcomplex_asin (double *, double *);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..8844..  ddoouubbllee **SSLLccoommpplleexx__aaccooss ((ddoouubbllee **,, ddoouubbllee **));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        double *SLcomplex_acos (double *, double *);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..8855..  ddoouubbllee **SSLLccoommpplleexx__aattaann ((ddoouubbllee **,, ddoouubbllee **));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        double *SLcomplex_atan (double *, double *);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..8866..  ddoouubbllee **SSLLccoommpplleexx__eexxpp ((ddoouubbllee **,, ddoouubbllee **));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        double *SLcomplex_exp (double *, double *);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..8877..  ddoouubbllee **SSLLccoommpplleexx__lloogg ((ddoouubbllee **,, ddoouubbllee **));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        double *SLcomplex_log (double *, double *);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..8888..  ddoouubbllee **SSLLccoommpplleexx__lloogg1100 ((ddoouubbllee **,, ddoouubbllee **));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        double *SLcomplex_log10 (double *, double *);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..8899..  ddoouubbllee **SSLLccoommpplleexx__ssqqrrtt ((ddoouubbllee **,, ddoouubbllee **));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        double *SLcomplex_sqrt (double *, double *);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..9900..  ddoouubbllee **SSLLccoommpplleexx__ssiinnhh ((ddoouubbllee **,, ddoouubbllee **));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        double *SLcomplex_sinh (double *, double *);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..9911..  ddoouubbllee **SSLLccoommpplleexx__ccoosshh ((ddoouubbllee **,, ddoouubbllee **));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        double *SLcomplex_cosh (double *, double *);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..9922..  ddoouubbllee **SSLLccoommpplleexx__ttaannhh ((ddoouubbllee **,, ddoouubbllee **));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        double *SLcomplex_tanh (double *, double *);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..9933..  ddoouubbllee **SSLLccoommpplleexx__ppooww ((ddoouubbllee **,, ddoouubbllee **,, ddoouubbllee **));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        double *SLcomplex_pow (double *, double *, double *);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..9944..  ddoouubbllee SSLLmmaatthh__hhyyppoott ((ddoouubbllee xx,, ddoouubbllee yy));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        double SLmath_hypot (double x, double y);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  extern double *SLcomplex_asinh (double *, double *);

  1122..9955..  ddoouubbllee **SSLLccoommpplleexx__aaccoosshh ((ddoouubbllee **,, ddoouubbllee **));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        double *SLcomplex_acosh (double *, double *);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..9966..  ddoouubbllee **SSLLccoommpplleexx__aattaannhh ((ddoouubbllee **,, ddoouubbllee **));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        double *SLcomplex_atanh (double *, double *);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..9977..  cchhaarr **SSLLddeebbuugg__mmaalllloocc ((uunnssiiggnneedd lloonngg));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        char *SLdebug_malloc (unsigned long);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..9988..  cchhaarr **SSLLddeebbuugg__ccaalllloocc ((uunnssiiggnneedd lloonngg,, uunnssiiggnneedd lloonngg));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        char *SLdebug_calloc (unsigned long, unsigned long);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..9999..  cchhaarr **SSLLddeebbuugg__rreeaalllloocc ((cchhaarr **,, uunnssiiggnneedd lloonngg));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        char *SLdebug_realloc (char *, unsigned long);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..110000..  vvooiidd SSLLddeebbuugg__ffrreeee ((cchhaarr **));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        void SLdebug_free (char *);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..110011..  vvooiidd SSLLmmaalllloocc__dduummpp__ssttaattiissttiiccss ((vvooiidd));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        void SLmalloc_dump_statistics (void);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..110022..  cchhaarr **SSLLssttrrccppyy((rreeggiisstteerr cchhaarr **,, rreeggiisstteerr cchhaarr **));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        char *SLstrcpy(register char *, register char *);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..110033..  iinntt SSLLssttrrccmmpp((rreeggiisstteerr cchhaarr **,, rreeggiisstteerr cchhaarr **));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        int SLstrcmp(register char *, register char *);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..110044..  cchhaarr **SSLLssttrrnnccppyy((cchhaarr **,, rreeggiisstteerr cchhaarr **,, rreeggiisstteerr iinntt));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        char *SLstrncpy(char *, register char *, register int);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..110055..  vvooiidd SSLLmmeemmsseett ((cchhaarr **,, cchhaarr,, iinntt));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        void SLmemset (char *, char, int);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..110066..  vvooiidd SSLLeexxppaanndd__eessccaappeedd__ssttrriinngg ((rreeggiisstteerr cchhaarr **,, rreeggiisstteerr cchhaarr
  **,, rreeggiisstteerr cchhaarr **));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        void SLexpand_escaped_string (register char *, register char *,
        register char *);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..110077..  vvooiidd SSLLmmaakkee__lluutt ((uunnssiiggnneedd cchhaarr **,, uunnssiiggnneedd cchhaarr **,, uunnssiiggnneedd
  cchhaarr));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        void SLmake_lut (unsigned char *, unsigned char *, unsigned
        char);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

  1122..110088..  iinntt SSLLaanngg__gguueessss__ttyyppee ((cchhaarr **));;

      SSyynnooppssiiss
        ??

      UUssaaggee
        int SLang_guess_type (char *);

      DDeessccrriippttiioonn
        ??

      SSeeee AAllssoo
        ??

